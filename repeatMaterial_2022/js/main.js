// console.log('Hello wr1d!')

// Строгий режим: "use strict"
/*
Когда такая строка прописана мы говорим нашему js файлу что мы работаем в современном режиме
    где не работают некоторые неточности которые были в старых форматах js

*/ 

/*
Имя переменной может состоять из букв, цифр, из символов $ и _
Первый символ у нас никогда не должен быть цифрой, спец.символа кроме $ и _
Названия переменных не должны повторять зарезервированные слова в языке: например error, prompt, alert и тд

Переменные пишуться в формате camelCase - верблюжья нотация
Переменные написанные в разном регистре это разные переменные 

Проблема переменной через var что переменная уже существует до того как она была объявлена в коде 
Если мы так сделаем , то мы получим не ошибку ,а undefined - какое-то значение

Поведение когда мы можем использовать переменную еще до того как она была объявлена - называеться hoisting
Или всплытие переменных

Название переменной:
    - Должны быть понятными и уникальными: vehicleBodyWidth - ширина кузова транспортного средства

 snake_case - это один из вариантов названия файлов и папок, но не переменных в js
 UPPER_SNAKE_CASE - такие переменные обозначают разработчики которые они хотят видеть в виде констант. 
    Их никогда нельзя переопределять
    
const COLOR_RED = '#F00'

Kebab-casw - название папок и файлов 
_apiBase - для получения данных

PascalCase - 

Когда мы создаем переменную ее значение сохраняется в ячейке области памяти 

Типы данных
    - Простые типы (Примитивы)
        - Числа 
        - Строки
        - Логический тип
        - null
        - undefined
        - Symbol
        - BigInt
    - Объектные типы (Комплексные)
        - Массивы
        - Функции
        - Объекты Даты
        - Регулярные выражения
        - Ошибки

`` - косые ковычки или бэктики

obj.name = 123;
obj['name'] = 123 - eslint будет ругаться т.к этот способ не очень хороший

к ключам объекта можно обращаться 2 способами. Через точку или через []

Разница между объектами и массивами:

Массив: это перечень информации по порядку
    - у каждой сущности есть свой номер по порядку. По этим номерам мы можем обращаться к этим сущностям
К элементу обращаться arr[1] - название массива и номер элемента в квадратных скобках
Ключевая особенность это именно порядок элементов

Объект: 
    - это структура хранения данных в парном формате

Массивы это частный случай объектов - если посмотреть в глубь массивов, то это теже объекты просто у них ключ это всегда номер по порядку

const arrObj = {
    0: 1,
    1: 2,
    2: 3
}

Но javascript плохо понимает подход с цифрами. Поэтому вместо цифр ставиться строка 'a'
И eslint ошибки не видит. Т.к javascript думает что мы обращаемся к какой-то переменной, а не свойству объекта

Простое общение с пользователем:

    alert, confirm, prompt 

Вся информация которая приходит от пользователя будет в виде строк. В не зависимости он того число ввел пользователь или строку
Но если мы поставим перед +prompt , то тип данных автоматически сконвертируется в введеный пользователем

Запись ответов пользователев в массив:

const answers = []

answers[0] = +prompt('Сколько вам лет?', '')
answers[1] = +prompt('Ваша фамилия?', '')
answers[2] = +prompt('Ваше имя?', '')

Второй параметр это значение по умолчанию как placeholder

typeof - оператор проверки типа данных содержащихся в переменной

Есть вещи в JS которые существуют только внутри браузера


Интерполяция:
    - прямо внутри строки можем вставлять значение переменной

const category = 'toys'

console.log(`https://someurl.com/${category}/5`)


Операторы JavaScript:

&& - и 
|| - или
! - оператор отрицания. Меняет значение на противоположное

console.log(isCheked && !isClose) - по типу условного рендера в React

Также у операторов в JS есть свой приоритет и свой вес 

Git и GitHub
    - используется для хранения и работы с кодом с удаленных серверов

GitFlow - подход для работы git в коммерческой разработке

Подключение GitHub через SSH

HTTP - обменн данными в интернете без защиты
HTTPS - защищеный протокол обмена данными. Использует SSL сертификат

Авторизация в Git аккаунт с SSH происходит с помощью ключей: открытый и закрыт


Условия:
    
Тернарное условие

isChecked ? true : false;

(5 === 10) ? return 'Условие верно!' : return 'Условие не верно!';

isClick ? <ButtonClick /> : <FormActive/>

Как альтернатива if else можно использовать switch case поддерживает использование нескольких проверок и условий
Сравнение происходит на строгое сравнение 

Логические операторы: 
    - все эти операторы нам что-то возвращают. Т.е дают какой-то результат

Результат логический операций - это обычное boolean значение

const hamberger = 2
const fries = 1

if (hambuerger === 3 && fries) {
    console.log('Все сыты!')
}

Если первое условие false, то остальной код выполняться не будет
Или || запинаеться на правде
Если все не правда возвращаеться последнее ложное значение

Внутри вложенного цикла i меняется на j

Методы и свойства строк и чисел


Метод trim():
    - метод схлопывает пробелы с начала и с конца строки

Используеться при взаимодействии с пользователем. Проверка на дурака. 
Пользователь может поставить лишние пробелы которые попадут в БД. Нам это не нужно

Callback функция выполняеться строго после завершения другой функции

Деструктуризация объектов: 
    - объекты в JS это так называемые ассоциативные массивы

for (let key in options) { - чикл чтобы пробежаться по массиву

}
const { color, bg } = options - деструктруризация объекта

Массивы и псевдомассивы

Массив - это структура которая содержит элементы по порядку

Если в массив вставить или удалить элемент - произойдет пересчет порядка элементов. Это снижает производительность


*/ 
import "./styles.css";

export default function App() {
  return (
    <div className="App">
      <h1>Hello CodeSandbox</h1>
      <h2>Start editing to see some magic happen!</h2>
    </div>
  );
}
