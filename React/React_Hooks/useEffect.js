/*
Reacr Hooks - useEffect:
    - основная задача заключается в том чтобы дать понять, что сейчас компонент что-то сделал

Например у нас есть кнопка и нам нужно понять что эта кнопка действительно внедрилась в страницу 
Т.е она уже внедрена в страницу и потом будет отображена

Для того чтобы определить это действие мы будем использовать хук useEffect


Реализация в классовых компонентах:
    - в классовых компонентах есть специально заготовленные методы. Мы сами можем выбрать какой именно нам использовать

Суть в том что эти методы нам позволяют понять сейчас с компонентом что-то произойдет либо что уже произошло

Методы: Основные 3 метода
    
    - componentDidMount - данный метод говорит о том что сейчас компонент первый раз был внедрен на страницу
И больше этот метод вызываться не будет до тех пор пока компонент не удалится и снова не отобразится на странице.
Вызываеться только один раз

    - componentDidUpdate - говорит о том что сейчас произошло обновление, а именно обновились какие-то props
или же произошло обновление state. И для того чтобы отловить эти действия и понять что имеено изменилось, 
можно использовать этот метод
И уже получить новые данные, старые данные и произвести какую-то сверку и потом выполнить какое-то действие

    - componentWillUnmount - благодаря этому методу мы можем понять что сейчас компонент будет удален
И до того как компонент удалится с какой-то там части нашего приложения мы можем выполнить какое-то действие 
У нас есть возможность заранее понять что сейчас компонент удаляется и сделать какое-то действие


Принципы работы:

    - componentDidMount
У нас есть компонент, далее он внедряется в страницу. Когда он действительно был внедрен в страницу вызывается метод componentDidMount
Этот метод нам сказал, что сейчас компонент был внедрен и если хочешь я могу что-то сделать. Например взять и получить с сервера данные 
Т.е у нас есть возможность понять что сейчас компонент был внедрен и что-то сделать дополнительно

    - componentDidUpdate
У нас есть компонент, условно он меняет цвет с синего на желтый. Эти изменения отображаются на странице. После того как изменения 
отобразились на странице(т.е произошли все эти изменения) у нас вызывается componentDidUpdate

Этот метод говорит что сейчас произошло что-то. Именно произошло какое-то обновление. При этом componentDidMount вызываться не будет,
будет вызываться только componentDidUpdate. Когда произошло обновление компонента в этот метод будет передоваться 2 параметра:
1. Старые props и старый state. Потом мы можем взять и сравнить старые данные с новыми и произвести какие-то действия

    - componentWillUnmount
Далее у нас все также есть какой-то компонент и например он удаляется именно когда происходит удаление заранее выполнятеся метод
которые называется componentWillUnmount. Данный метод позволяет сделать что-то до того как будет удален сам компонент

class List extends React.Component {
    state = {
        numbers: [1,2,3]
    }

    addRandomNumber = () => {
        const ranNumber = Math.round(Math.random() * 10)
        this.setState(() => {
            numbers: [...numbers, randNumber]
        })
        
    }

    render(
        return(
            <React.Fragment>
                <ul>
                    {
                        this.state.numbers.map((num, index) => {
                            return (
                                <li key={index}>{num}</li>
                            )
                        })
                    }
                </ul>
                <button onClick={this.addRandomNumber}>Новое число</button>
            <React.Fragment|>
        )
    )
}

Класс наследуется от React.Component. И теперь он является классовым компонентом

Если мы пишем классовый компонент мы должны написать, что наш классовый компонент должен хранить какой-то метод
Метод называется render(). Благодаря этому методу наш компонент будет что-то отображать

Объяснить что состояние state является объектом. И внутри объекта есть специальные свойства

Теперь мы объяснили что внутри нашего компонента list есть состояние state внутри которого есть какие-то данные

this - обращается к нашему классу и говорит, что этот класс хранит свойство state. Внутри state есть numbers и это массив

Благодаря тому что мы смогли наследоваться от React.Component мы можем использовать setState
Он будет каждый раз мы вызове метода setState обновлять объект и производить обновление самого компонента
setState говорит что нам нужно взять state и его обновить

this.setState(() => {
    numbers: [...this.state.numbers, randNumber] - переменная numbers будет обновляться на массив
})
Свойство numbers должно быть обновлено на массив [...numbers, randNumber]
Но переменной numbers у нас нет, но она есть у класса. Чтобы получить до нее доступ нужно ...this.state.numbers

Везде пишется слово this т.к мы работаем с контекстом класса и все находится внутри класса


Как определить жизненный цикл классового компонента?

В нашем классовом компоненте List мы можем написать специальный метод.
Поробуем начать с того был ли наш компонент отображен на странице, был ли он вмантирован в нашу страницу 
Чтобы это понять, пишем componentDidMount

Благодаря этому методу мы сможем понять что наш компонент был внедрен в страницу

componentDidMount() {
    console.log('Hello')
}

Мы можем просто написать, что есть такой метод componentDidMount он ничего не получает
И внутри этого метода мы можем написать что как только мы поймем что компонент был внедрен в страницу мы что-то сделаем

При этом если мы каждый раз будем добовлять новое число componentDidMount выполняться не будет
componentDidMount выполняется только в том случае когда в первый раз произошло монтирование внутри самой страницы

Теперь нужно понять что компонент был обновлен. Т.е изменились ли props или state. В нашем случае мы меняем state при вызове метода
И нам нужно это отлавить. Понять что сейчас компонент произвел обновление для это используем componentDidUpdate
Т.е когда компонент будет обновлен вызывается метод componentDidUpdate

Данный метод получает 2 аргумента: 1. Это старые props, 2. Это старый state

componentDidUpdate(prevProps, prevState) {
    console.log(prevProps, prevState)
}

prevProps - предыдущий props
prevState - предыдущий state

При первом рендере нашего приложения выполняется console.log() который говорит что компоент List был отображен и вызывался console.log()
При этом у нас не вызывается componentDidUpdate. Не вызывается по той причине, что у нас не произошло никакое обновление
У нас произошол только первый рендер но обновления не произошло

При нажатии на кнопку происходит обновление state и вызывает componentDidUpdate который выводит в консоль аргументы
Мы получаем пустой объект. Т.е наш компонент List не получает никакие props, второй аргумент хранит state в котором хранится numbers
Мы видим что prevState возвращает нам старое состояние, старые данные. Поэтому мы можем взять и сравнить новые данные с старыми данными
И проверить нужно ли что-то делать или нет


Как сравнить старые данные с новыми?

componentDidUpdate(prevProps, prevState) {
    console.log(prevProps, prevState, nextProps: this.props, nextState: this.state)
}

componentWillUnmount
    - данный метод будет вызываться до того как компонент будет удален с страницы

componentWillUnmount() {

}


React.useEffect(() => {

}, [numbers])

- Когда произойдет какое-то действие мы можем сделать что-то и в этой фукции мы описываем что делать

Далее для того чтобы объяснить что нам нужно в нашем функциональном компоненте нужно делать componentDidMount
Для этого вторым аргументом мы передаем зависимости. И решает что с ними делать, как он будет работать

useEffect 2 аргументом получает пустой массив - это значит componentDidMount
Для useEffect пустой массив обозначает что не за какими переменными следить не нужно
Т.е нужно вызываться всего лишь один раз когда отобразится компонент

Если мы не будем передавать ничего 2 аргументом useEffect будет выполняться каждый раз когда будет происходит обновление или отображение первый раз
Будет выполняться каждый раз когда произойдет первый рендер или обновление  

Если мы хотим следить за конкретной переменной которая будет меняться мы передаем ее в масств

Выполняет он по той причине что useEffect при первом вызове начинает сравнивать старые зависимости с новыми
И он видит что старые зависимости которые были при первом вызове useEffect они отличаются от тех которые мы передали

<button onClick={() => setCount(count + 1)}></button>

useEffect следит за обновлением только тех переменных которые были переданы как параметры в массив 2 аргументом
При каждом изменении переменной выполняется функция логика которой прописана в useEffect до того как выполнится действие

Если мы хотим следить за изменениями чего либо мы убираем массив зависимостей
Если мы хотим отловить componentDidMount мы передаем пустой массви
Если мы хотим отловить componentDidUpdate мы передаем зависимости в массив
Если мы хотим отловить componentWillUnmount мы возвращаем аннонимную

React.useEffect(() => {
    console.log('componentDidMount') - эта часть выполниться только при componentDidMount
    return () => { - эта часть выполниться только при componentWillUnmount
        console.log('componentWillUnmount')
    }
}, [numbers])

Аннонимная функция не выполняется при componentDidMount она ждет когда компонент умрет






*/
