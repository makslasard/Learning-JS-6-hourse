/*
Основная задача useState - это хранение плоских состояний, когда у нас есть одно значение которое меняется


Раньше в React использовались классовые компоненты

Оснавная ключевыя идия реакт компонентов

- Есть определенный стейт. Т.е есть объект описывающий состояние компонента и если он меняется, 
то реакт перерисовыет непосредственно ту область где этот стейт выводится

Если мы использовали классовые компоненты, то мы там использовали метод this.setState({a: 1}) -> this.render()
Туда мы добавляли какое-то новое значение, и после этого вызывался метод this.render()
Который брал и перерисовывал нам компонент

Все эти методы они наследовались от базового класса от которого мы наследовались в реакте
Но позже реакт решил перейти полностью к функциональным компонентам, чтобы все наши компоненты были не классами, а функциями

Почему? 
Как минимум потому что с этим проше взаимодействовать чем с классами
Плюс меньше кушает ресурсов, потому что мы не наследуемся от других сущностей
У нас всего лишь есть функция и всё

Соответственно чтобы полностью мигрировать на функциональные компоненты нужно было как-то соблюсти динамику 
Как минимум как-то взаимодействовать с стейтом. Как раз для этого появились Хуки

Хуки - это просто абсолютно изолированные функции которые предостовляет Реакт, но которые позволяют посути полностью имплементировать 
весь функционал Реакта в базовых компонентах функциональных 

Вся эта идея взята из функционального программирования и у нее также есть еще плюсы
- В том что код который мы пишем становится более гибким и более масштабируемым

// useState
- Предназначен для того чтобы взаимодействовать с стейтом (состоянием)

import React, {useState} from 'react'


function App() {
    const counterState = useState(0)

    retrun (
        <div>
            <h1>Счетчик</h1>
            <button>Добавить</button>
            <button>Убрать</button>
        </div>
    )
}

export default App

Чтобы нам поработать с счетчиком нам нужно для начала ввести некоторое состояние
Мы сразу будем вводить это состояние через новый хук useState

Он используется следующим образом:
- Мы можем его получить из самого Реакта (Объекта реакт). У него есть метод useState

Но обычно вы можете заметить его использование немного иным способом, когда мы отдельно достаем этот Хук с помощью ES6 синтаксиса
И используем как обычную функию

С помощью Хука useState мы начинаем взаимодействовать с стейтом 
- Как параметр в данную функцию мы передаем начальное состояние - этого состояния
В нашем случае это будет 0, мы хотим чтобы наш счетчик начинался с нуля

Теперь важно то, что возвращает нам Хук useState
Если мы посмотрим в косоль что такое counterState
То сдесь мы увидим возможно неожиданный результат, мы получаем здесь массив 

Где первый элемент данного массива это непосредственно само состояние
А второй элемент массива это фукния. Функия которая позволяет изменять данное состояние 

Array(2) 
    0: 0, 
    1: f()

И вот в чем заключается идея:

- Функция Хук useState нам возвращает кортеж
Кортеж это массив с заранее определенными элементами которые в нем находятся 
Где первый элемент [0] по индексу ноль. Это непосредственно тот стейт который мы должны определять в сам шаблон

А второй элемент это функция позволяющая изменять этот стейт для того чтобы реакт смог отследить что:
- Стейт изменился и перерисовать шаблон для того чтобы мы напрямую не меняли данное состояние 

const [counter, setCounter] = useState(0) - как аргумент передается значение counter

1. Параметр это состояние
2. Это функция позволяющая изменить counter. Обычно называют с префиксом set

Если мы берем внутри JSX пишем фигурные скобки мы говорим React что сейчас будет JS код

let numbers = [1, 2, 3]

{
    numbers.map(num => <li>{num}</li>)
}

map проходится по массиву и на каждой иттерации генерирует JSX элемент с id 

!!! Но есть предупреждение. 
    - Когда мы создаем список где мы берем массив и превращаем этот массив в JSX элементы, компоненты
Мы должны обязательно объяснить React что каждое значение которое будет приобразовано во что-то и отрендерено
у него есть свой уникальный ключ что каждый генерируемый li является уникальным

Наша основная задача когда мы производим генерацию какого-то JSX элемента объяснить что оно униклаьно и 
у него есть собственный ключ. Что именно у родительского элемента есть ключ

Нужно как атрибут добавить key={index}

const addNumber = () => {
    numbers.push(4)
}

<button onClick={addNumber}>Новое число</button>

const [state, setState] = React.useState([1, 2, 3])
const [numbers, setNumbers] = React.useState([1, 2, 3])

Мы создаем деструктурирующий массив
(Мы берем какие-то свойства и превращаем в переменные)

useState() - возвращает массив
Теперь useState будет передавать массив в другую переменную

state - функция будет использовать эту переменную
setState - будет использовать для обновления переменной state и оповещать React

numbers - будет хранить какие-то данные 
setNumbers - это функция которая будет менять numbers и оповещать наш компонент

Array(2) 
    0: 0, 
    1: f()

const addNumber = () => {
    const randNumber = Math.round(Math.random() * 10)
    setNumbers([...numbers, randNumber])
}

Функция setNumbers - просто производит замену
Массив numbers каждый раз будет заменяться на новый массив

Хук useState нужно использовать когда нужно производить re-render при изменениях
Если массив не будет меняться, то хук использовать не нужно

Т.е переменная с данным будет заменятся на результат второго аргумента полностью

































*/