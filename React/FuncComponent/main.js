/*
Описание работы с функциональными компонентами;

1. Хук useState: const [count, setCount] = useState(initialValue)
    - В качестве initialValue мы можем передать функцию

    Пример: Получение данных из LocalStorage
    
    const [value, setValue] = useState(() => {
        const userCount = localStorage.getItem('count')
        return +userCount || 0
    })

2. Хук useEffect
    - Хук useEffect - полностью ассинхронный. Любой функционал который мы внутри напишем 
        не будет блокировать поток приложения
    - useEffect может быть много на странице. Если у нас будет больше чем 2 useEffect,
        то каждый раз придется гадать какой useEffect за что отвечает

        Для этого иногда остовляют комментарии для самого useEffect

        Либо внутри useEffect используеться не аннонимная функция, а имеенная

            useEffect(fuction getDataFromDB() {
                console.log()
            }, [])

    - Если у нас пустой массив зависимостей функция размонтирования сработает один раз        


    - Содержит в себе функциональность 3 методов жизненного цикла
    - Пишеться обычно перед return
    - Ни к чему не присваиваеться, пишеться сам по себе

    - Принимает 2 сущности: 1. Функция которую мы хотим выполнить. 2. Зависимость за которой следит useEffect
    - Зависимсоти должны быть всегда, могут быть пустыми
    - Если зависимости пустой, выполниться один раз (Этап монтирования)
    - Этап обновления используеться с добовлением зависимости

    - Чтобы использовать метод Размантирования мы используем return
    - Выполняеться при размантировании и обновлении зависимости

    // Отвечает за запрос данных из БД
    useEffect(() => {
        console.log('ComponentDidMount + ComponendDidUpdate')

        return () => console.log('ComponentWillUnmount')
    }, [count])

3. Хук useRef: const inputEl = useRef(null)
    - Изначально у нас формируеться объект с единственным ключом current и в него передаеться значение в ()

Мы можем из полученного input получать разные значения
Рефы бывают полезны чтобы их как-то менять
El - пожелания чтобы разделить одного рода рефы с другими

Чтобы мы могли прибовлять по несколько значений нужно использовать prevState
setCount((prevState) => prevState + 1)
setCount((prevState) => prevState + 1)
setCount((prevState) => prevState + 1)

Каждое последующее вычесление будет по очереди ссумироваться
В итоге получиться клик за 3 числа


Хук useContext: файл useContext.jsx
    - для начала работы нужно импортировать React и функцию createContext

export const CustomContext = createContext()

    - Теперь CustomContext имеет у себя 2 метода Consumer, Provider
В зависимости для чего мы будем использовать context мы будем использовать 2 метода либо 1

Мы будем использовать хук useContext поэтому Consumer нам не понадобиться он будет использовать
    его под капотом

Создадим компонент, он будет называться Context. Компонент может называться как угодно
    Он будет принимать props, а самое главное будет внутри себя иметь некоторый state
    Внутри state у нас будут коллекция книг. Через массив объектов

export const Context = (props) => {
    const [books, setBooks] = useState([
        {id: 1, title: 'JavaScript'},
        {id: 2, title: 'React'},
        {id: 3, title: 'Redux'}
    ])
}

Мы хотим сделать историю в которой мы все это пробрасываем вниз и где-то добавляем или удаляем 
Создадим отдельно методы чтобы работать с состоянием

Далее наш компонент будет возвращать <CustomContext.Provider /> с Provider
В данном случае мы будем оборачивать все то что придет к нам через props.children

children - особый props в котором храняться дочерные элементы если они были переданы нашему компоненту
По сути Provider как-бы обнимает все компоненты которые будут в него переданы
В дальнейшем компонент useContext вы подключим на уровне приложения и все остальные компоненты будут относительно
    него дочерними

И все дочерние компоненты будут получать доступ к тому что мы положим в поле value
Мы можем в поле value напрямую набрасать какой-то объект
    может быть просто число, просто строка, просто переменная с какой-то сущностью

Обычно чтобы сущность была более веселой обычно это объект. 
    Можно создать снаружи можно создать внутри объект value

Мы создали специальный компонент который внутри себя скрывает некоторую логику
    У него есть данные, есть методы изменяющие эти данные
    И он все их готов предоставить кому угодно кто будет являться его дочерним элементом

Мы возьмем все наше приложение и обернем в контекст (В наш кастомный компонент)
    И уже внутри него мы что-то будем использовать


Хук useLayoutEffect:
    - похож на useEffect но практически не используеться

Делает тоже самое что и useEffect 

Основное отличие:
    - useEffect у нас работает ассинхронно и не блокирует общую отрисовку страниц

    - useLayoutEffect выполняеться синхронно может блокировать отрисовку
Перед тем кагда делать отрисовку браузерного DOM может дополнительно сделать еще работу
    которая может привести еще к перередеру


Хуки useCallback и useMemo:
    - 

useCallback - внутрь передаем функцию и некоторый набор зависимостей
    Возвращает мемоизированный фариант функции запомненной
    В тот момент когда параметры этой функции меняються у нас происходит перерасчет функции
        и результат сохраняется в кэшированное пространство и сохроняеться новый вариант этой
        функции только с другими параметрами

Просто возвращает функцию которую мы планируем куда-то передать и вызвать        


Хук useMemo: 
    - принимает некоторую функцию и 2 аргументом некий массив зависимостей
        Когда один элемент внутри массива зависимостей изменился происходит перерасчет и 
        возвращаеться мемоизированное значение

Возвращает значение которое мы где-либо используем

Использование useCallback и useMemo требуют определенных ресурсов                                     
useMemo - может пригодиться когда нам нужно будет сделать какие-то серьезные вычисления

Хуки нужны когда идут большие вычисления
Чтобы использовать нужно обернуть функцию в useCallback или React.memo

const ClearButton = React.memo(({}) => {})

const increment = useCallback(() => {}, [])


Хук useReducer:
    - концепция хука пришла к нам из Redux. Это существенно упрощенная модель.  

Возвращает нам 2 сущности:
    - это state по умолчанию
    - это функция обновления dispatch()

const [{...objectOne}, dispatch] = useReducer(reducer, {})

reducer - функция которая будет обрабатывать actions

- может работать только с 1 reducer
- нет middleware


Кастомные хуки:
    - usePrevious
    - useLocalStorage

Правило хуков:

    - Использовать хуки только на верхнем уровне
    - Не вызывать хуки из обычных функций




*/

