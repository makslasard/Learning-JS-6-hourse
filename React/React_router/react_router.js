/*
React Router 6 - базовый роутинг React-приложения

1. Нужно установить в зависимости react-router-dom
2. Импортировать из react: import { BrowserRouter } from 'react-router-dom'

Он должен быть родительским компонентом относительно всего нашего приложения
Это позволяет сделать роутинг внутри нашего приложения

Роутинг предполагает SPA который позволяет не перезагружать страницу, а подгружать нужнные данные 

Чтобы начать работать нам нужно импортировать в компонент <App /> дополнительные вещи
import { Routes, Route, Link } from 'react-router-dom'

Также нужно подготовить страницы импортированные в <App /> как компоненты 
import { Homepage } from './pages/Homepage'

Для роутинга у нас будет базовый компонент <Routes />
И дочерним компонентов у нас будет компонент <Route />

<Routes>
    <Route path='./' element={<Homepage />}/>
    <Route path='./about' element={<Aboutpage />}/>
    <Route path='*' element={<Aboutpage />}/>
<Routes />

Мы будем говорить, что у нас есть <Route /> на определенный адрес в браузере
Вместо сслыки мы ставим слэшь это наша корневая директория, т.е главная страница

И дальше мы должны сказать какой компонент за это дело отвечает
Мы указыавем prop element и передаем сам компонент через JSX разметку 

Такой подход используют очень многие библиотеки, и в данном случае React-router-dom сделал унификацию
Позволяя испльзовать так как исопльзуют многие другие

Если нам нужно передать в компонент какие-то props мы можеми это сделать 
В случаях если ничего не найдено у нас будет отрисовываться компонент(страница) nodefound
* - для всех остальных случаев

Ссылки заменяются на компонент link

<header> - без роутинг. Страница при переходе будет перезагружаться 
    <a href='/'>Home</a>
    <a href='/posts'>Blog</a>
    <a href='/about'>About</a>
</header>

<header> - с роутингом. Страница при переходе не будет перезагружаться 
    <Lin to='/'>{<Home />}</Lin>
    <Link to='/posts'>{<Blog />}</Link>
    <Link to='/about'>{<About />}</Link>
</header>

Пример:

return(
    <>
        <header> - с роутингом. Страница при переходе не будет перезагружаться 
            <Lin to='/'>Home</Lin>
            <Link to='/posts'>Blog</Link>
            <Link to='/about'>About</Link>
        </header>
        <Routes>
            <Route path='/' element={<layout/>}>
                <Route index element={<Homepage />}/>
                <Route path='./about' element={<Aboutpage />}/>
                <Route path='*' element={<Aboutpage />}/>
            </Route>
        <Routes />   
    </>
)


Общая разметка и компонент Outlet в React-Router 6
    - Чтобы было проше управлять общими элементами на страницы мы выносим их в отдельный компонент Layout

Для этого нам нужен еще один дополнительный компнент который называется Outlet
Outlet - суть заключается в том чтобы сказать нашей разметке куда вставить все остальное 

    <header>
        .....
    </header>

    <Outlet />

    <footer>
        .....
    </footer>

И мы делаем компонет Layout родительским роутом, а все остальные роуты с страницаими делаем дочерними
Это компонент обертка который будет показываться всегда 

В рамках этой обертки мы можем динамически что-то менять
При этом Layout предостовляет Outlet куда будут отрисовываться все дочернее содержимое

Чтобы нам сказать, что у нас есть компонент который точно по этому адресу работает мы используем ключевое слово index
В таком случае все остальные адреса, могут спокойно идти без слеша
Относительно родительского слеша у нас все остальные страницы которые есть и которые мы можем создать

Мы в одном файле Layout разметка по сути даем какие-то базовые характеристики с container с компонентами
стилизуем как нам нравится и говорим что вся динамика будет в <Outler />
И организуем ее за счет вложенных роутов внутри нашего базового роута


Компонент NavLink и его кастомизация в React-Router 6

<header> - с роутингом. Страница при переходе не будет перезагружаться 
    <NavLink to='/'>Home</NavLink>
    <NavLink to='/posts'>Blog</NavLink>
    <NavLink to='/about'>About</NavLink>
</header>

В дело вступает новый подход, мы можем сделать хитрый className
Библиотека спроектировала prop таким образом принимает не только строки, но и функции
Причем автоматически в эту фукнцию будет передан определенный параметр он передает сюда объект у которого есть ключ isActive
Который как раз и проверяет активна эта ссылка или нет 

const setActive = ({isActive}) => isActive ? 'active-link' : '' 

<NavLink to='/' className={setActive}>Home</NavLink>

Так можно сделать на все ссылки и это будет работать также как раньше, только с другим имененм класса
И вынести этот функционал в отдельную переменную, это будет правильней и локаничней


















*/
