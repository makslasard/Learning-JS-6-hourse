/*
Разработка production приложения:

!!! В webpack.confing.js мы используем require т.к работаем в среде NODEJS

1. Иничиализация проекта с помощью команды: npm init -y
    -y дефолтные настройки

    packege.json:
        - следить за зависимостями
        - заводить скрипты которые будут использоваться в нашем проекте

    Создадим папку src 
        - в ней будет храниться исходный код нашего приложения

        - для теситирования создадим пару файлов

        index.js - это входная тогда для нашего приложения

        test.js - для того чтобы протестировать import и export
            функций переменных и всего что можно экспортировать

            В test.js создадим случайную функцию и в логи выведем просто текст
            Тест не удался. Потому-что по умолчанию export и import не работают
            Это касаеться не только NodeJS, но и браузера

        И теперь нам на помощь приходит Webpack:
            - это сборщик который очень гибко позволит нам сконфигурировать сборку нашего приложения,
                т.е на вход мы передаем некое кол-во разных файлов и он генерирует нам статику
                js код, html, какие-то изображения, css

                Эту статику мы по итогу мы заливаем на хостинг и приложение доступно в интернете
                
                Webpack также позволяет оптимизировать код, cжать его, оптимизировать

    1.1. Установка нужных зависимостей 
        
        - Установка Webpack: npm install webpack webpack-cli --save-dev
            Версия которая установиться по этой команде будет самая новая, и могут возникнуть проблемы
                при работе с старыми проектами

            Установка определенной версии: npm i -D webpack@5.69.1 webpack-cli@4.9.2
                Меняя цифры можно корректировать нужную версию зависимости

            Мы устанавливаем Webpack чтобы работать через командную строку

            ВАЖНО!!! 
                Зависимости мы устанавливаем -D как зависимости т.к участвуют только при разработке

                После того как мы приложение собрали, нам эти зависимости уже не нужны

2. Работа с документацией Webpack

    - Далее в документации: Using Configuration нам рекомендуют в корне проекта создать файл
        webpack.config.js

        Именно в этом файле будет вся конфигурация нашей webpack сборки

    - Далее мы пишим начальный шаблон для начала работы

        Это аналог обычного export, но это версия для NodeJS

        module.exports = {

        }

        1. Первое и одно из самых важных свойств которое мы должны указать: 
            entry = './src/index.js' - стартовая точка нашего приложения
        
            Но так хардкодить пути это не очень хорошая практика, потому-что в разных операционных
                системах пути работают по разному. И по хорошему для создания путей нужно использовать

            Поскольку Webpack работает в среде NodeJS ему доступен стандартный модуль path и 
                у него есть функция resolve с помощью которой мы можем склеить участки пути

            __dirname - это адрес корневой папки

            Дальше через запятую мы указываем участки пути: 'src', 'index.js'
                это как раз путь до стартовой точки нашего приложения файла index.js

            path.resolve(__dirname, 'src', 'index.js')    

        2. Второе свойство output
            - это настройки того как мы будем делать сборку нашего приложения

            2.1  Мы указываем название filename. 
                Это как будет называться главный файл сборки нашего приложения: bundle.js

            2.2 Путь куда наша сборка должна приходить
                Используем метод path: path.resolve(__dirname, 'build')


        3. Чтобы запустить сбоку нужно в терминале написать команду: webpack

            В консоле мы видим ошибку: что мы не указали 'mode'
            mode = 'development' или 'production'

        4. В корне проекта у нас появилась папка build в ней лежит файл с названием bundle.js
            Теперь в проекте нам доступны export и import к которым мы привыкли

        5. В module.exports = {} добавляем поле mode: 'development' (на этапе разработки)
            mode: 'production' - когда мы уже публикуем наше приложение

            Если webpack видит mode: 'production' - он автоматические оптимизирует код
                сжимает, убирает лишнее, убирает комментарии, минифицирует файлы чтобы быстрее
                отправить данные пользователю на клиент

        6. На текущем этапе у нас уже небольшая рабочая сборка

            const path = require('path')

            module.exports = {
                mode: 'development',
                entry: path.resolve(__dirname, 'src', 'index.js'),
                output: {
                    filename: 'bundle.js',
                    path: path.resolve(__dirname, 'build')
                }
            }

            Но есть одна проблема что файл у нас всегда называеться bundle.js 
            В браузере встроены миханизмы оптимизации которые кэшируют файлы и позволяют
                достаточно быстро их отдавать из кэша не загружая каждый раз с сервера

            output: {
                    filename: '[name].js',
                    path: path.resolve(__dirname, 'build')
                }

                В output название файла указано в квадратных скобках - это некоторые шаблоны с 
                    помощью которых мы можем задавать динамические названия для наших файлов

                Теперь мы снова запускаем сборку с помощью команды 'webpack' и в папке 
                    build появился файл main.js 

                Это название как раз entry которое мы указали. По дефолту оно называеться main 
                Это название мы можем поправить и даже указать несколько entry поинтов если такие существуют

                Для этого вместо строки обычного пути можно указать объект где ключом будет являться название
                    entry point, а значением как раз путь до этого entry point

                module.exports = {
                    mode: 'development',
                    entry: {
                        RANDOM: path.resolve(__dirname, 'src', 'index.js')
                    },
                    output: {
                        filename: '[name].js',
                        path: path.resolve(__dirname, 'build')
                        clean: true
                    }
                }

                Но в нашем случае это не нужно, т.к у нас всего один entry point

        7. Проблема с кэшированием 7:25       
                - Если у нас каждый раз одно и тоже название файла, браузер его кэширует и каждый раз
                    отдает старый файл. А что если мы выкатили новую версию нашего приложения, а пользователю
                    все равно будет отдаваться старая версия

                В таком случае можно добавить шаблон: .[contenthash]
                    main.4f95e982d721ae28a3e4.js

                И в зависимости от содержимого файла будут генерироваться уникальные названия ключи 
                    Проблема с кэшированием таким образом решена

                Обратите внимание что при каждой сборке у нас собираеться определенное кол-во ненужных
                    файлов и по хорошему их нужно подчищать

                Для этого у output нужно добавить: clean: true

Вывод:  
    - На данный момент наш webpack умеет работать с js файлами. Он их может собирать, использовать
        import и export внутри и по итогу отдавать нам минимизированный или development код

    Но также в нашем приложении поскольку мы разрабатываем frontend у нас должен быть html file

        1. Для этого мы создадим папку public и в ней создадим index.html file он будет
            нашим корневым html файлом. Файл с которого будет начинаться наше приложение        

        2. В body создадим блок с классом root: <div className="root"></div>   
            В него мы будем имплементировать наше react приложение

            Далее webpack нужно сообщить где этот файл лежит и по мимо того в этой файл 
                необходимо вставить те самый js скрипты которые мы будем писать

            Для этого у webpack есть потрясающий механизм плагинов который могут выполнять
                такие различные операции

        3. Для дальнейшей работы нам нужна зависимость: 'html-webpack-plugin'    
                Установка зависимости: npm i -D html-webpack-plugin@5.5.0

            После установки плагина его нужно добавить в наш webpack
                plugins: []

                Используется через массив т.к плагинов может быть много
            
            Для того чтобы подключить установленный плагин его нужно импортировать
                webpack.confing.js через require

            Также мы импортируем webpack

            На сайте webpack также можно посмотреть все возможные плагины и почитать как они работают
                - это официальные плагины которые подтверждены webpack

            Поскольку плагин который мы импортировали: html-webpack-plugin
                - это класс, то нам нужно создать объект из этого класса мы используем конструкцию
                    new HtmlWebpackPlugin()

            Запустим команду webpack и увидим что в папке build появился файл index.html
                Он имеет стандартную структуру и новое в теге script
                <script defer src="main.4f95e982d721ae28a3e4.js"></script>    

                В качестве script это файл который webpack получил в качестве сборки
                Т.е он автоматически этот скрипт подключает за нас

                Если скриптов много это удобно. Нам не приходится следить за их порядком и не 
                    приходиться добавлять их в ручную

        4. Поиск 2 плагина
            - сейчас у нас сборка происходит за доли секунды, но когда проект разрастется
                сборка может занимать много времени. По хорошему за сборкой нужно следить
                и понимать сколько процентов сборки уже произошло
                
                Для этого есть: webpack.ProgressPlugin
                Он идет по дефолту в пакете webpack

        5. Решение проблемы с появлением в сборке блока .root   
            - дело в том что он каждый раз создаеться с нуля и при использовании плагина         
                HtmlWebpackPlugin({
                    template
                }) 
                
                давать определенные настройки через объект

                Мы хотим из папки public использовать как шаблон, чтобы в него встраивались скрипты

        6. Проблема с типизацией 
            - на текущий момент мы можем работать с JS, но не можем работать с TS

                Сейчас TS это стандард в разработке и любой более менее крупный проект
                    без TS практически не разрабатываеться. Поэтому webpack нам необходимо подготовить         

            Находим нужную документацию и прям по пунктам выполняем:    
                1. Установка 2-х пакетов TypeScript и ts-loader
                    npm i -D typescript@4.5.5 ts-loader@9.2.6

                2. Установка файла tsconfig.json и поменять расширения файлов с js на ts
                    в папке src.

                    - Чтобы удедится что TS работаем просто добим в файл аргумент

                    - Далее в документации ищем базовый пример файла tsconfig.json

                    - Возвращаемся в webpack.config.js и меняем в entry point расширение
                        файла с js на ts

                3. После добавления TS у нас происходят изменения в webpack.config.js 
                    - Поле rules 
                        - Одно из самых важных полей в Webpack

                        Здесь мы конфигурируем так называемые лоадеры. Они предназначены для того
                            чтобы обрабатывать файлы которые выходят за рамки JavaScript
                        
                        Например: png, jpeq, gif, svg, css, scss, ts

                        module: {
                            rules: [
                                {
                                    test: /\.tsx?$/,
                                    use: 'ts-loader',
                                    exclude: /node_modules/,
                                },
                            ],
                        },

                    ts-loader - это загрузчик для webpack, который интегрирует typescript в
                        webpack. Это преобразует файлы с расширением .ts в файлы .js и 
                        объединяет их    


                    3.1 Лоадер для TypeScript
                        - Поле test 
                            В этом поле мы указываем регулярное выражение по которому мы будем
                                находить файлы которые необходимо пропустить через лоадеры
                                    test: /\.tsx?$/,

                            В данном случае это файлы с расширением .tsx       
                            Это регулярное выражение будет обрабатывать файлы как .ts, .tsx 

                        - Поле use
                            Тут мы указываем как именно лоадер нужно использовать для таких файлов

                        - Поле exclude
                            Тут мы исключаем папку node_modules

                    - Поле resolve
                        В поле resolve в данном случае поле extensions указываем расширение
                            тех файлов при импорте которых мы НЕ будем указывать расширени

                        При импорне компонентов нам теперь не нужно указывать Component.tsx,
                            а сразу пишем просто Component

                        resolve: {
                            extensions: ['.tsx', '.ts', '.js'],
                        }

                        Для вот эти 3 типов файлов мы не будем указывать расширение
                        Это просто облегчает немного нам работу 18:09


































*/