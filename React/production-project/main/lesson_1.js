/*
Разработка production приложения:

!!! В webpack.confing.js мы используем require т.к работаем в среде NODEJS
!!! Важно! чтобы все пакеты были нужной версии т.к все сломаеться если ts будет новых версий, а пакеты старых
!!! При каждом запуске сборка у нас собираеться новый JS файл с хэщированием 

1. Иничиализация проекта с помощью команды: npm init -y
    -y дефолтные настройки

    packege.json:
        - следить за зависимостями
        - заводить скрипты которые будут использоваться в нашем проекте

    Создадим папку src 
        - в ней будет храниться исходный код нашего приложения

        - для теситирования создадим пару файлов

        index.js - это входная точка для нашего приложения

        test.js - для того чтобы протестировать import и export
            функций переменных и всего что можно экспортировать

            В test.js создадим случайную функцию и в логи выведем просто текст
            Тест не удался. Потому-что по умолчанию export и import не работают
            Это касаеться не только NodeJS, но и браузера

        И теперь нам на помощь приходит Webpack:
            - это сборщик который очень гибко позволит нам сконфигурировать сборку нашего приложения,
                т.е на вход мы передаем некое кол-во разных файлов и он генерирует нам статику
                js код, html, какие-то изображения, css

                Эту статику мы по итогу мы заливаем на хостинг и приложение доступно в интернете
                
                Webpack также позволяет оптимизировать код, cжать его, оптимизировать

    1.1. Установка нужных зависимостей 
        
        - Установка Webpack: npm install webpack webpack-cli --save-dev
            Версия которая установиться по этой команде будет самая новая, и могут возникнуть проблемы
                при работе с старыми проектами

            Установка определенной версии: npm i -D webpack@5.69.1 webpack-cli@4.9.2
                Меняя цифры можно корректировать нужную версию зависимости

            Мы устанавливаем Webpack чтобы работать через командную строку

            ВАЖНО!!! 
                Зависимости мы устанавливаем -D как зависимости т.к участвуют только при разработке

                После того как мы приложение собрали, нам эти зависимости уже не нужны

2. Работа с документацией Webpack

    - Далее в документации: Using Configuration нам рекомендуют в корне проекта создать файл
        webpack.config.js

        Именно в этом файле будет вся конфигурация нашей webpack сборки

    - Далее мы пишим начальный шаблон для начала работы

        Это аналог обычного export, но это версия для NodeJS

        module.exports = {

        }

        1. Первое и одно из самых важных свойств которое мы должны указать: 
            entry = './src/index.js' - стартовая точка нашего приложения
        
            Но так хардкодить пути это не очень хорошая практика, потому-что в разных операционных
                системах пути работают по разному. И по хорошему для создания путей нужно использовать
                модуль path

            Поскольку Webpack работает в среде NodeJS ему доступен стандартный модуль path и 
                у него есть функция resolve с помощью которой мы можем склеить участки пути

            __dirname - это адрес корневой папки

            Дальше через запятую мы указываем участки пути: 'src', 'index.js'
                это как раз путь до стартовой точки нашего приложения файла index.js

            path.resolve(__dirname, 'src', 'index.js')    

        2. Второе свойство output
            - это настройки того как мы будем делать сборку нашего приложения

            2.1  Мы указываем название filename. 
                Это как будет называться главный файл сборки нашего приложения: bundle.js

            2.2 Путь куда наша сборка должна приходить
                Используем метод path: path.resolve(__dirname, 'build')


        3. Чтобы запустить сбоку нужно в терминале написать команду: webpack

            В консоле мы видим ошибку: что мы не указали 'mode'
            mode = 'development' или 'production'

        4. В корне проекта у нас появилась папка build в ней лежит файл с названием bundle.js
            Теперь в проекте нам доступны export и import к которым мы привыкли

        5. В module.exports = {} добавляем поле mode: 'development' (на этапе разработки)
            mode: 'production' - когда мы уже публикуем наше приложение

            Если webpack видит mode: 'production' - он автоматические оптимизирует код
                сжимает, убирает лишнее, убирает комментарии, минифицирует файлы чтобы быстрее
                отправить данные пользователю на клиент

        6. На текущем этапе у нас уже небольшая рабочая сборка

            const path = require('path')

            module.exports = {
                mode: 'development',
                entry: path.resolve(__dirname, 'src', 'index.js'),
                output: {
                    filename: 'bundle.js',
                    path: path.resolve(__dirname, 'build')
                }
            }

            Но есть одна проблема что файл у нас всегда называеться bundle.js 
            В браузере встроены миханизмы оптимизации которые кэшируют файлы и позволяют
                достаточно быстро их отдавать из кэша не загружая каждый раз с сервера

            output: {
                    filename: '[name].js',
                    path: path.resolve(__dirname, 'build')
                }

                В output название файла указано в квадратных скобках - это некоторые шаблоны с 
                    помощью которых мы можем задавать динамические названия для наших файлов

                Теперь мы снова запускаем сборку с помощью команды 'webpack' и в папке 
                    build появился файл main.js 

                Это название как раз entry которое мы указали. По дефолту оно называеться main 
                Это название мы можем поправить и даже указать несколько entry поинтов если такие существуют

                Для этого вместо строки обычного пути можно указать объект где ключом будет являться название
                    entry point, а значением как раз путь до этого entry point

                module.exports = {
                    mode: 'development',
                    entry: {
                        RANDOM: path.resolve(__dirname, 'src', 'index.js')
                    },
                    output: {
                        filename: '[name].js',
                        path: path.resolve(__dirname, 'build')
                        clean: true
                    }
                }

                Но в нашем случае это не нужно, т.к у нас всего один entry point

        7. Проблема с кэшированием 7:25       
                - Если у нас каждый раз одно и тоже название файла, браузер его кэширует и каждый раз
                    отдает старый файл. А что если мы выкатили новую версию нашего приложения, а пользователю
                    все равно будет отдаваться старая версия

                В таком случае можно добавить шаблон: .[contenthash]
                    main.4f95e982d721ae28a3e4.js

                И в зависимости от содержимого файла будут генерироваться уникальные названия ключи 
                    Проблема с кэшированием таким образом решена

                Обратите внимание что при каждой сборке у нас собираеться определенное кол-во ненужных
                    файлов и по хорошему их нужно подчищать

                Для этого у output нужно добавить: clean: true

Вывод:  
    - На данный момент наш webpack умеет работать с js файлами. Он их может собирать, использовать
        import и export внутри и по итогу отдавать нам минимизированный или development код

    Но также в нашем приложении поскольку мы разрабатываем frontend у нас должен быть html file

        1. Для этого мы создадим папку public и в ней создадим index.html file он будет
            нашим корневым html файлом. Файл с которого будет начинаться наше приложение        

        2. В body создадим блок с классом root: <div className="root"></div>   
            В него мы будем имплементировать наше react приложение

            Далее webpack нужно сообщить где этот файл лежит и по мимо того в этой файл 
                необходимо вставить те самый js скрипты которые мы будем писать

            Для этого у webpack есть потрясающий механизм плагинов который могут выполнять
                такие различные операции

        3. Для дальнейшей работы нам нужна зависимость: 'html-webpack-plugin'    
                Установка зависимости: npm i -D html-webpack-plugin@5.5.0

            После установки плагина его нужно добавить в наш webpack
                plugins: []

                Используется через массив т.к плагинов может быть много
            
            Для того чтобы подключить установленный плагин его нужно импортировать
                webpack.confing.js через require

            Также мы импортируем webpack

            На сайте webpack также можно посмотреть все возможные плагины и почитать как они работают
                - это официальные плагины которые подтверждены webpack

            Поскольку плагин который мы импортировали: html-webpack-plugin
                - это класс, то нам нужно создать объект из этого класса мы используем конструкцию
                    new HtmlWebpackPlugin()

            Запустим команду webpack и увидим что в папке build появился файл index.html
                Он имеет стандартную структуру и новое в теге script
                <script defer src="main.4f95e982d721ae28a3e4.js"></script>    

                В качестве script это файл который webpack получил в качестве сборки
                Т.е он автоматически этот скрипт подключает за нас

                Если скриптов много это удобно. Нам не приходится следить за их порядком и не 
                    приходиться добавлять их в ручную

        4. Поиск 2 плагина
            - сейчас у нас сборка происходит за доли секунды, но когда проект разрастется
                сборка может занимать много времени. По хорошему за сборкой нужно следить
                и понимать сколько процентов сборки уже произошло
                
                Для этого есть: webpack.ProgressPlugin
                Он идет по дефолту в пакете webpack

        5. Решение проблемы с появлением в сборке блока .root   
            - дело в том что он каждый раз создаеться с нуля и при использовании плагина         
                HtmlWebpackPlugin({
                    template
                }) 
                
                давать определенные настройки через объект

                Мы хотим из папки public использовать как шаблон, чтобы в него встраивались скрипты

        6. Проблема с типизацией 
            - на текущий момент мы можем работать с JS, но не можем работать с TS

                Сейчас TS это стандард в разработке и любой более менее крупный проект
                    без TS практически не разрабатываеться. Поэтому webpack нам необходимо подготовить         

            Находим нужную документацию и прям по пунктам выполняем:    
                1. Установка 2-х пакетов TypeScript и ts-loader
                    npm i -D typescript@4.5.5 ts-loader@9.2.6

                2. Установка файла tsconfig.json и поменять расширения файлов с js на ts
                    в папке src.

                    - Чтобы удедится что TS работаем просто добавим в файл аргумент

                    - Далее в документации ищем базовый пример файла tsconfig.json

                    - Возвращаемся в webpack.config.js и меняем в entry point расширение
                        файла с js на ts

                3. После добавления TS у нас происходят изменения в webpack.config.js 
                    - Поле rules 
                        - Одно из самых важных полей в Webpack

                        Здесь мы конфигурируем так называемые лоадеры. Они предназначены для того
                            чтобы обрабатывать файлы которые выходят за рамки JavaScript
                        
                        Например: png, jpeq, gif, svg, css, scss, ts

                        module: {
                            rules: [
                                {
                                    test: /\.tsx?$/,
                                    use: 'ts-loader',
                                    exclude: /node_modules/,
                                },
                            ],
                        },

                    ts-loader - это загрузчик для webpack, который интегрирует typescript в
                        webpack. Это преобразует файлы с расширением .ts в файлы .js и 
                        объединяет их    


                    3.1 Лоадер для TypeScript
                        - Поле test 
                            В этом поле мы указываем регулярное выражение по которому мы будем
                                находить файлы которые необходимо пропустить через лоадеры
                                    test: /\.tsx?$/,

                            В данном случае это файлы с расширением .tsx       
                            Это регулярное выражение будет обрабатывать файлы как .ts, .tsx 

                        - Поле use
                            Тут мы указываем как именно лоадер нужно использовать для таких файлов

                        - Поле exclude
                            Тут мы исключаем папку node_modules

                    - Поле resolve
                        В поле resolve в данном случае поле extensions указываем расширение
                            тех файлов при импорте которых мы НЕ будем указывать расширение

                        При импорте компонентов нам теперь не нужно указывать Component.tsx,
                            а сразу пишем просто Component

                        resolve: {
                            extensions: ['.tsx', '.ts', '.js'],
                        }

                        Для вот эти 3 типов файлов мы не будем указывать расширение
                        Это просто облегчает немного нам работу 18:09


        8. config для webpack на typescript     

            - webpack typescript config file вводим в поисковую строку и видим раздел 
                документации configuration languages

            Документация советует установить несколько пакетов            
                1. npm install --save-dev typescript ts-node@10.5.0 @types/node@17.0.21 @types/webpack@5.28.0        

                    Следующее действие это поменять расширение webpack.confing.js на ts версию
                        webpack.config.ts

                
            2. Замена require() на import и export
                    - import и export идут в TypeScript по умолчанию

                import * as path from 'path'; через * as      

                Дело в том что изначать эти пакеты предназначены для NodeJS, а tsconfig.json
                    для обычных import сейчас не предназначен

                Чтобы сделать import более привычными нужно добавить флаг "esModuleInterop": true
                    в tsconfig 
                
                И флаг: "allowSyntheticDefaultImports": true,
                    - синтетически позволяет импорты более привычными

                esModuleInterop - позволяет работать с пакетами, которые используют CommonJS
                    как с обычными пакетами с помощью import        
                        "esModuleInterop": true

                "allowSyntheticDefaultImports": true
                    Когда мы пишем какие-то React приложения, мы можем использовать export default и 
                        именнованный export. Многие библиотеки особенно которые написаны на NodeJS
                        не поддерживают default import. И нам приходиться писать * as чтобы явно
                        обозначая что мы хотим импортировать все
                        
                        Этот пакет как раз и позволяет писать import и export в привычном для нас стиле

9. TypeScript config
    - moduleResolution: 'node' - определяет какие импорты будут. Содержит всего 2 свойства
        node и classic. В 99% случаев используется node

    - allowJS: 'true' - позволяет компилятору обрабатывать не только TS файлы но и JS файлы
    - jsx: 'react' - чтобы мы могли писать привычные react конструкции

    - target: 'es5' - указываем версию EcmaScript в какую версию наш код будет компилироваться. 
        Обычно компилируют либо в es5 либо es6. И делаеться это для того чтобы большинство браузеров
            поддерживались

    - module: 'ESNext' - мы указываем модульную систему. Обычно используют ESNext 

    - "noImplicitAny": true - свойство не позволяет использовать переменные без явного указания типа                    

    - "outDir": "./dist/" - место куда производится сборка. В нашем случае это не столь важно т.к
        собираем с помощью webpack                    

10.

    - Для конфига создадим отдельную переменную и туда закинем всю конфигурацию                    

Пример webpack.config.ts

import path from 'path'
import HtmlWebpackPlugin from 'html-webpack-plugin'
import webpack from 'webpack'

const configWebpack = {
    mode: 'development', - режим разработки
    entry: path.resolve(__dirname, 'src', 'index.ts'), - входная точка приложения
    output: { - все о том куда будет собираться приложение
        filename: '[name].[contenthash].js', имя файла плюс хэш
        path: path.resolve(__dirname, 'build'), - путь до файла
        clean: true, - все старые файлы удаляються 
    },
    plugins: [ - дополнительные инструменты
        new HtmlWebpackPlugin({ - плагин для генерации html
            template: path.resolve(__dirname, 'public', 'index.html'), - куда будут добавляться скрипты
        }),
        new webpack.ProgressPlugin(), - плагин для отслеживания прогресса сборки в процентах
    ],
    module: { - подключения модуля для работы с TypeScript и упрощения работы
        rules: [
            {
                test: /\.tsx?$/, - регулярное выражение которое ищет .ts, .tsx файлы и позволяет при импорте не писать расширение 
                use: 'ts-loader', - лоадер с помащью которого это можно все делать
                exclude: /node_modules/, - исключение 
            },
        ],
    },
    resolve: {
        extensions: ['.tsx', '.ts', '.js'], - к какому типу файлов не нужно писать расширение
    },
}

export default configWebpack
                    

    - Далее чтобы пользоваться плюшками autocomplete нужно добавить в configWebpack типизацию
        для конфига тип wepback.Configuration

        При попытке произвести сборку у нас появляется ошибка: 
            import path from 'path';
            ^^^^^^

            'SyntaxError: Cannot use import statement outside a module'

            Если мы почитаем сообщение то поймем что ругаеться на импорты

            Далее мы идем смотреть в документацию и там написано: 
                Что если в модуль мы указали CommonJS, то настройка закончена. В обратном случае нужны
                    дополнительные настройки потому-что ts-node по умолчанию не поддерживает ничего
                    кроме CommonJS

                - У нас есть 3 пути:
                    1. Изменить tsconfig
                    2. Изменить tsconfig и добавить настройко ts-node
                    3. Либо что-то еще :))

                В нашем случае оставить модуль ESNext и добавить дополнительные настройки для ts-node

                {
                "compilerOptions": {
                    "module": "ESNext",
                },
                "ts-node": {
                    "compilerOptions": {
                    "module": "CommonJS"
                    }
                }

Вывод: 
    1. Настроили небольшой config приложения
    2. Научились работать с TypeScript
    3. Перевели конфирурацию wepback.config также на TypeScript
    4. Сконфигурировали tsconfing и разобрали свойства за которые они отвечают














































*/