/*
Курс React от Михаила Непомнящего: 10.11.2022

index.jsx - когда мы называем файл с конкретным расширением и имеем определенный набор подсказок которые нам 
    предостовляет та, или иная среда с которой мы работаем. Теперь в правом нижнем углу отображаеться тип 
    файла {} JavaScript React.

Т.е это разные наборы подсказак в зависимости от расширения. И плюшек от Emmet

Инструкции - мы не можем использовать внутри JSX
if()
switch()
for/while

props.children - дает доступ до вложенных сущностей в компоненте
<Book name='JS for beginer' year='2018'>Text here</Book>

В данном случае доступ до внутренностей компонента Book до Text here
Если компонент будет без вложенности в себя, то props.children не приходит

Если export default фигурные скобки не используем 
Если export {} фигурные скобки используем

Если внутри компонента нам не нужен функционал который дает React, то его можно не импортировать


Классовые компоненты в React:
    
Нам нужен не просто класса, а класс который будет наследоваться (extends) от React.Component
React.Component - это свой класс с своим набором методов, переменных, заранее подготовленных
    И все эти сущности мы берем и наследуем в свой класс который как-то пробуем переопределять

Как у любого класса есть свой constructor. В нашем случае он принимает некоторые props если мы 
    предпологаем что в данный компонент были спущены props. И внутри метод super()

Props через метод super(props) передать в родительский класс


Состояние компонента и управление им:
    - Все что меняеться мы как правило должны сохранять

State (состояние) - храниться в переменной this.state. Как правило это объект в котором храняться
    определенные поля. Мы не можем напрямую изменять состояние. Для этого используеться функция setState()
    Она приходит от наследования React.Component

setState({})

Принимает новый объект с каким-то ключом

handleClick = () => {
    this.setState({count: this.state.count + 1})
  }

Мы предпологаем что изменился один ключ. Мы только его и указываем

Все остальное React проделает самостоятельно. Он сам отследит какие там есть ключи, что они не изменились
  он просто вернет их в том виде в котором они были. Мы передаем только тот ключ который поменялся

В данном случае мы говорим что нам нужно обновить поле count и его новое состояние это:
  возьми старое состояние и добавь к нему 1

handleClick = () => {
    this.setState((prevState) => ({count: prevState.count + 1}))
  }

Если мы напишем несколько раз функцию с помощью prevState на один проход будет прибовляться столько 
  значений, сколько у нас кол-во функций. Наша функция setState может принимать второй параметр. 
  Это некоторый callback который выполниться после того как произойдет изменение state

Чаще всего используется первый формат

handleClick = () => {
    this.setState({count: this.state.count + 1})
  }

 handleClick() { // Метод не поймет что за this используется. this будет undefined
    this.setState({count: this.state.count + 1})
  }

При использовании такого метода нужно обязательно использовать bind привязку context
  
Понятие жизненного цикла компонента:
  
componentDidMount() {} - функция которая выполняеться до появления компонента на странице
  Как правило в ней можно увидеть запросы данных. Еще называеться монтированием. Выполняеться одни раз

componentWillUnmount() {} - функция выполняеться перед удолением элемента с страницы.
  Выполняеться один раз. Размонтирование
  
сomponetDidUpdate() {} - функция выполняеться каждый раз когда происходит обновление контретного компонента
  Называеться обновление






*/

