/*Строчные элементы*/
/*Блочные элементы*/
/*Строчно - блочные элементы*/
/*https://htmlreference.io/ справочник чтобы узнать какой элемент строчный, блочный, строчно-блочный, является ли мета-тегов, требуется ли закрывающийся тег,*/ 

/*
Блочные элементы: 
- Сайт состоит из различных блоков в которых находятся элементы, header, footer, промежуточные блоки
- Классический блочный элемент div. Занимает всю область сайта по ширине
- Блочные элементы очень жадные 
- Если не указывать блочным элементам ширину, элемент займет все доступное пространство по ширине 
- Если не указывать блочным элементам высоту, элемент сожмется на ширину контента и установленные padding
- У каждого элемента есть свои стили по умолчанию: user agent stylesheet - параметры по умолчанию
- Свойство box-sizing: border-box; - изменяет поведение блока. Уменьшает все внутренние элементы чтобы следовать заданным высоте и ширине контента.
- При установлении фиксированных значений блоку свойства принимает лишь контент, а остальные padding, margin, border суммируются
- * звездочка, это селектор всего. Мы применяем правила ко всему что будет на странице 

Строчные элементы: 
- Строчные элементы нужны для наполнения сайта 
- Строчные элементы занимают в блоке столько места сколько в них контента
- Если ты не можешь отодвинуть элемент сверху или снизу, нужно проверить не является ли он строчным
- Строчные элементы не реагируют на свойства ширины, они занимают ровно столько места сколько в них есть контента 
- Картинки в HTML это тоже строчные элементы. Они не будут являтся блоками 
- Тег P является блочным элементом 

Строчно-блочные элементы: 
- Взяли все самое лучшее из строчных и самое лучшее из блочных и объеденили их в себе 
- От блочных они взяли все параметры которые есть в блочной модели CSS, от строчных они взяли расположение в одной строке. Они уже не настолько жадные, не захватывают всё пространство
- Чтобы поставить картинку по центру, нужно изменить его на блочный элемент
- Свойство margin: 0, все внешние отступы ставятся в 0
- Свойство margin: 0 auto мы расположим картинку по центру только по горизонтали 
- Если мы используем в margin 2 значения, то первое отвечает за вертикальное выравнивание и отступы, 2 за горизонтальное
*/

/*
Позиционирование элементов в CSS. Принцип карточной колоды:
- position: static - Статическое позиционирование производится по умолчанию, в том случае, если свойство position не указано
- position: relative - Относительное позиционирование сдвигает элемент относительно его обычного положения
- position: absolute: 
  Элемент исчезает с того места, где он должен быть и позиционируется заново. Остальные элементы, располагаются так, как будто этого элемента никогда не было
  Координаты top/bottom/left/right для нового местоположения отсчитываются от ближайшего позиционированного родителя, т.е. родителя с позиционированием, отличным от static. Если такого родителя нет – то относительно документа.
  При установке элемент как бы выподает из списка HTML, становится не попорядку, а там где мы укажем

- position: absolut работает только внутри блока у которого стоит position: relative . Т.е у родительского 
- Если мы хочешь абсолютно спозиционировать какой-то элемент, внутри другого элемента, то обязательно установите позитион абсолют у родительского элемента
- Если ты так сделаешь элемент будет внутри блока
- position: fixed - приклеивается к позиции на экране, и остается даже при скроле
- position: inherit - означает что мы берем свойство и наследуем его от его родителя. Наследуем позиционирование родителя
- Если класс стоит последним он будет перебивать ранее добавленный цвет

Принцип карточной колоды: 
- Свойство z-index: 5; - отвечает за позиционирование элементов по оси Z. Может принимать числовые значения, в том числе и отрицательные 
- Тот элемент который больший index, большее число тот и выходит на первый план
- Если нужно убрать на задний план элемент с абсолютным позиционированием нужно поставить отрицательный z-index: -1;
*/


/*
Выравнивание элементов по вертикали. Верстка таблицами и float'ами:
- Cвойство float - отвечает за обтегание текстом какого-то элемента 
- Чтобы картинку обтекали элементы справа нужно поставить float: left, и наоборот

- Проблема выравнивания блоком когда мы используем display: inline-block
- Чтобы нам выравнивать элементы по вертикали нам понадобится такое свойство как: vertical-align: top; middle, и т.д
- Это свойство работает только тогда когда у нас у элементов стоит display: inline-block

- Таблицами сайты мы уже не создаем - это прошлый век
*/

/*
Еденици измерения в CSS
- Изначально все величины можно разделить на 2 группы: Относительные единицы и Абсолютные единицы

- Процент %: - эта величина относительная. Она зависит от того какая ширина и высота у родителя этого элемента, она должна быть фиксированной. width: 50%; - установил ширину элемента относительно его родителя
- У некоторых элементов родительских элементов не существует
- em и ex: - величины которые зависять от высоты шрифта
- em - от высоты шрифта текущего элемента. Какой font-size там установлен
- ex - от высоты символа x. От размера быквы x на странице

- em: Мы берем размер шрифта в px и умножаем на em. 30px * 50em = 1500px
- На практике это не используется т.к это не удобно

- Новые единицы называются: rem, vh, vw
- Это относительные величины которые зависят от какого-то другого параметра
- rem: - величина зависит от размера шрифта, только уже корневого элемента. А не самого элемента в котором применяется данная величина. Тег html 
- vw - 1|100 ширины нашего окна
- vh - 1|100 высоты нашего окна

Специфичность CSS селекторов: 
- Различные способы стилизации различных элементов они имеют разный приоритет в понятии стилей это называется специфичность
- Какой-то селектор будет более специфичен чем другой (каскадность)
- Когда мы что-то стелизуем с помощью тегов, то такие стили являются менее специфичными
- Классы являются более специфичными т.к класы определяются на определенные элементы
- Если у нас есть несколько классов у одного элемента, то применяются стили если они конфиктуют у последнего класса. Второй стиль является как бы более важным более специфичным
- Когда мы задаем id в CSS - он будет очень специфичным. Т.к это правило может повторятся только для одного элемента. Оно будет перебивать все остальные
- Самые специфичные это inline стили которые пишутся в HTML в теге style. Их никогда не используют
.wrapper .element {} - вложенные классы перебивают все. С пробелом
- Если мы используем вложенность классов, то она будет специфичней чем какой-то отдельный класс
- Когда мы используем комбинацию селекторов она становится намного специфичней
.wrapper.element {} - без пробела.

Градация специфичности селекторов:
1. element.style{}
2. #second.element{}
3. #second{}
4. .wrapper .element{}
5. .element{}

Flexbox и применение её на макете: 
- Служит для выравнивания любых элементов на сайте

Чтобы flexbox включить нужно display: flex;
Когда мы ставив display: flex; у родителя.
Flexbox построен на принципе осей: 1 вариант Есть главная (горизонтаьлная) ось и поперечная (вертикальная) ось
Также 2 вариант мы можем поменять направление осей, сделав поперечную ось главной, а главную поперечной

Когда мы ставим display: flex; по умолчанию стоит именно 1 вариант

1. Если нужно выронить элементы по главной (горизонтальной) оси
!!! ВАЖНО. Все свойства display: flex; и последующие мы применяем именно для контейнера (родителя)

.my-flex-container { - родительский контейнер
  display: flex;
  justify-content: center; - мы хотим сказать что нужно выровнять все элементы по центру
  justify-content: space-between; - элементы красиво распределятся по всей ширине родительского блока
  justify-content: space-around; - элемены равномерно распределены по всей ширине блока

  align-items: center; - все элементы выровнялись по горизонтали по центру внутри родителя
}
1. Все элементы встали по центру экрана
2. justify-content: - отвечает за выравнивание элементов по главной оси
3. align-items: - щтвечает за выравнивание элементов по поперечной оси

Особенности flexbox: 
1. Переполнение контейнера
Если вдруг не хватает места в строке, часть элементов спустилась бы ниже 
flex-wrap: wrap; - задаёт правила вывода flex-элементов —  в одну строку или в несколько, с переносом блоков.
wrap - Расположение в несколько линий

2. Мы можем устанавливать порядок изменения блоков задав всем элементам позицию на которой они должны быть

3. Изменение осей
flex-direction: column; - поперечная становится главной (вертикальная), поперечная главной (горизонтальная)
flex-directinon: row; - по умолчанию. Главная горизонтальня, поперечная вертикальная

При изменении направления осей все методы работают подругому. Отталкиваются от главной оси

!!! ВАЖНО. Чтобы начать использовать в проекте flex-box нужно у всех элементов внутри блока убрать свойство display: inline, inline-block, block
Также убрать отступы и выравнивание margin и vertical-align
Убрать нужно все что конфликтует с flex-box

Сброс стилей reset.css/normalize.css:
- Используется для сброса стандартных стилей браузера для приведение страницы к одному формату во всех браузерах
CSS Reset - это небольшой css файл который сбрасывает все настройки стилей для всех элементов чтобы они везде выглядели одинаково

На смену CSS Reset пришел normolize.css - который не только сбрасывал все стили в 0. Он делал это более по умному
Он оптимизировал только те стили которые необходимо. 
Чтобы те элементы у которых была разница в разных браузерах выглядели теперь одинаково
Это более продвинутая версия

Когда normolize.css не нужно подключать?
- Дела в том что normolize.css уже включен в некоторые библиотеки. Когда мы подключаете бибилиотеку то normolize.css уже встроен

Подключить normolize.css можно локально или удаленно: 
- Локально через css подключение файла
Сам файл нужно подключить перед гланым файлом css. Все сторонние библиотеки

- Удаленное подключение при помощи cdn серверов
Для использования в проектах нужно использовать толькои минифицированную версию т.к это ускоряет загрузку сайта
normolize.min.css


Подключение шрифтов на сайт:

Свойство font-family: определяет приоритетный список из одного или нескольких названий семейства шрифтов и/или общее имя шрифта для выбранного элемента.

1. Подключение стандартных шрифтов которые есть на ПК

font-family: Gill Sans Extrabold, sans-serif
Состоит из двух частей: 
- Мы прописываем свойсво font-family:
- Указываем название семейства шрифта который мы хотим использовать 
- Через запятую мы указываем общий тип

В шрифтах есть несколько общих типов названий: 
- Самые популярные это serif и sans-serif
serif - это шрифт с засечками
sans-serif - это шрифт без засечек

Пример записи шрифтов 
font-family: Verdana, Arial, Helvetica, sans-serif - устанавливаем приоритет шрифтов которые мы хотели бы подключить 

В примере несколько шрифтов которые написаны через запятые, а дальше что общий шрифт будет без засечек
Свойство font-family - поддерживает сразу несколько шрифтов 

Прежде чем подключить шрифт на сайте браузер ищет на компьютере пользователя шрифт который был прописан в font-family
Поэтому шрифтов несколько вариантов т.к если какого-то шрифта не будет подключится похожий следующий
И так пока не закончатся шрифты, если все равно шрифты не найдены выбрать любой который соответсвует шрифту sans-serif

Удаленное подключение шрифтов: 
- Есть такой сервис который называется Google Fonts он помогает настроить шрифт который нам нужен и подключить себя на проект

Настройка шрифтов осуществляется на сервере Google Fonts и все настройки помещаются в ссылку которую ты подключаешь на сайт через тек head
От количества подключаемых шрифтов и начертаний на странице зависит скорость загрузки нашей страницы

Как лучше подключать? Через link или import?
- Правельней и проше подключать через тег link

Чтобы начать использовать начертания и шрифт, мы применяем правило к всему документу к html или к body

html {
  font-family: Gill Sans Extrabold, sans-serif
}

После использования этого правила можно даже не использоывать font-family
А работать чисто с начетаниями
Если CSS не может найти шрифт, или в шрифте ошибка, или на ПК его нет, то будет использоваться шрифт по умолчанию

Для локального подключения шрифта нужно скачать шрифт и подключить в CSS
!!! ВАЖНО. Обязательно проверяй пути откуда будут братся шрифты, т.к если пути неправельные, то ничего работать не будет\
Все шрифты которые подключаются локально должны быть в отдельном файле

Если нужно подготовиться шрифты для корректной работы в разных браузерах, но в наличии они только в разных форматах
Нужно их конвертировать в другой формат через онлайн конвертер


Библиотека Boostrap 4: 
- Это набор готовых решений которые можно сразу использовать

Начнем использовать Bootstrap с переноса страртового шаблона в файл с проектом
В проектах используется минифицированные файлы чтобы сайт загружался быстрей

Также в Boostrap уже добавленны определенные опции

- У всех элементов уже строит box-sizing: border-box
- Сброшены все margin и padding
- Уже включена мини библиотека как rebot.css (Тоже самое что и normolize)
Если мы используем Boostrap, то нам не нужно отдельно подключать normolize и не нужно сбрасывать css правила

Вкладка components: 
- Показывает большое кол-во компонентов которые уже красиво созданны которые можно использовать

Создание пробного проекта: 
- Navbar - навигационное меню
Boostrap через классы мы можем использовать определенные уже стилизованные элементы

Основное преимущество Bootstrap это система сеток.
- Bootstap поддерживает колоночную верстку. Зачастую используеся 12 колоночная система
Каждый элемент занимает определенное количество колонок. Благодаря этим колонкам мы можем быстро адаптировать сайт под все устройства

Несколько главных правил для пользования сетками: 
- Использование контейнера бутстрап
Есть контейнер растянутый на весь экран container-fluid
Если мы хотим использовать колоночную верстку нужен обязательно просто container

- Строки .row
Для того чтобы колонки сработали нам всегда необходимы строки

- Колонки
Колонки всегда распологаются в строках. И создаются с помощью ключевого класса .col

- 4 правило
Для того чтобы у вас сработала такая колоночная верстка нужно строго следовать этому шаблону

.container {
  .row {
    .col {
    }
  }
}
Сначало контейнер, только внутри row как строка, только внутри колонка
Если вдруг вы где-то обернете колонку в какой-то отдельный блок, то ничего работать не будет 
Только таким образом можно использовать строки. Потому что все построено на flex-box

- 5 правило
Колонки можно модифицировать с помощью цифр в классах col-3 блок элемент займет 3 колонки. Всего 12 колонок
Если не указывать количество колонок для элемента, то Бутстрап разделить поровну между всеми элементами

Некоторые css классы используются в сокращенной форме в классах Бутстрап. Например mt-5 (margin-top: 50px)
Цифра 5 означает 50
В бутстрапе в Notation есть обозначение css классов и размеры

Еще приимущество колонок - это адаптивность

Зачастую в реальных проектах бутстрап используют только ради сеток
Остальные элементы используют редко. Зачастую библиотека смешивается с вашим css кодом

!!! ВАЖНО. Сетка подключается только в минифицированном формате для более быстрой загрузки файлов

Обновление Bootstrap 5 version: 
- Вместо JQuery использует обычный JS
- Библиотека полностью отказывается от поддержки браузера Internet Explorer
- css переменные. Теперь используются внутри Bootstrap 
- Сетка Bootstrap - поддержка экрана больше чем 1400px
- Bootstrap Icon
- Обновление некоторых css классов 

Практика: Создание сайта с использованием Bootstrap 5
- Подготовка структуры файлов и папок
- Export все картинок из Figma
- Подключение необъодимых css файлов 
- Подключение шрифтов

Тег conteiner мы можем использовать отдельно чтобы ограничить пространство
- Мы создаем меню с помощью семантического тега nav
Внутри мы должны создать список. Т.к меню подразумевает что у нас есть какой-то список ссылок по которым можем перейти пользователь
Ссылки мы можем пока забить заглушками. Если мы пока не знаем куда она будет вести или не хотим куда-то ставить

ВАЖНО!!! Чтобы управлять точками нужно делать на уровне ul. Свойство list-style: none;
justify-content: space-between; Распределяет равномерно элементы по контейнеру 1 и последний к границам родительского элемента

Свойство line-height: 15px; - нужен в основном для работы с многострочным текстом

Если мы используем свойство opacity: он будет устанавливать прозрачность всему элементу тем самым весь контент будет полу прозрачным
Чтобы использовать прозрачность только на background нужно использовать альфа-канал и свойство rgba(0,0,0 .6)
Где первые 3 нуля это смесь цветов, а .6 это прозрачность в сокращенном варианте 0.6

Правильное формирование путей
1. Не начинать формирование путей со слеша ( / )

Препроцессоры SCSS/SASS/LESS
- Препроцессор SASS самый популярный и востребованный

Обычно в проекте создается специальная папка, которая называется по имени того препроцессора который используют
И создается файл с расширением используемого препроцессора
!!! ВАЖНО. Браузер понимает только css код. Поэтому когда мы создаем проект мы подключаем именно css файл

Чтобы автоматические компилировать файл .sass в .css можно использовать программы, плагины,  webpack

Основное преимущество sass это полный отказ от фигурных скобок, и точек с запятыми. И исользование отступов
Отступы создаются с помощью клавиши Tab

h1
  color: red
  font-size: 50px
h2
  color: blue
  font-size: 25px

- Пример sass кода
Sass код компилируется сразу в оптимизированном виде (Стиль кода Production)
Если проект находится в разработке, то использовать стиль кода Development (Разработка)
Каждый пробел, каждый перенос строки, это лишняя информация и лишняя память

Также основное преимущество sass это вложенность селекторов

.block
  color: black
  font-size: 25px
    h3
      color: white
      font-size: 12px
    &_color
      color: $text_color
      button
        width: 250px

&_color - использование амперсанта &. Используется чтобы не писать .block_color используется более короткая запись

Когда мы задаем через амперсант. У нас появляется обычный класс
С помощью амперсанта мы создаем стилистику для определенного класса, который дополняется через определенный символ

Переменные в css
- Какие-то величины в проекте постоянно повторяются например цвет текста scout-app
Чтобы ее задать один раз, а потом переиспользовать мы можем создать переменную 
Обычно эти переменные записываются либо в отдельном файле либо сверху css файла

Создание переменной: 
$text_color: red

В переменную помещаются самые часто используемые свойства в проекте
- размеры шрифтов, цвет текста

Миксины
- Бывает так что в нашем кода повторяются целые блоки кода 

@mixin box
  display: block
  width: 250px
  height: 250px
  color: blue

Чтобы включить миксин нужно написать @include box как свойство

.block
  color: black
  font-size: 25px
  @include box - добавились свойства к уже написанным
    h3
      color: white
      font-size: 12px
    &_color
      color: $text_color
      button
        @include box

Если вдруг код не компилируется нужно проверить отступы, возможно в них ошибка

Компиляция кода с помощью VSCode
- Нужно установить плагин Live Sass Compiller

Разница между SASS/SCSS/LESS
- Выполняют все одну и туже задачу разница будет в синтаксисе, различных дополнительных примочках и способе компиляции

Вендорные префиксы: 
У каждого браузера есть свои особенности использования тех или иных свойств css
Чтобы избежать отличий в работе css правил были придуманы вендорные префиксы
Все префиксы запоминать не нужно, за тебя это всё будет делать компилятор и частности галочка autoprefixer
Если стоит галочка, то кампилятор автоматически будет подставлять то, что нужно для тех свойств которые в этом нуждаются

- Когда мы используем свойство с различными вендорными префиксами, мы само свойство css записываем всегда в конце
Это делается для того чтобы код сначала посмотрел на все префиксы, угадал в каком браузере работаем

- Некоторые css свойства могут быть написаны для конкретного браузера
- Некоторы свойства только дорабатываются. Могут быть в разработке
- Некоторые css свойства могут работать в некоторых браузерах лишь частично

Псевдоклассы и псевдоэлементы в CSS: webref.ru/css/pseudo-class

- Псевдоклассы - нужны чтобы управлять состоянием элементов
Например пользователь навел мышкой на элемент, или активный элемент, элемент в фокусе, мы можем выбрать каждый второй элемент и тд.
Все это характеризует состояние элементов 

Самые популярные псевдо классы: 
- hover: Отвечает за поведение элемента при наведении на него мышкой
- active: Определяет стиль активного элемента
- focus: Определяет стиль для элемента, получающего фокус
- nth-child: Позволяет указывать какой-то определенный элемент по порядку

Виды псевдоклассов: 

- Динамические псевдоклассы: Выбирают ссылки на странице, которые имеют атрибут href и находятся в определенном состоянии, а также некоторые другие элементы
    :link - не посещенная ссылка
    :visited - посещенная ссылка 
    :focus - ссылки, а также элементы форм, которые активированны посредством курсора мыши или на которые перешли с помощью клавиатуры (TAB)
    :hover - ссылки, а также другие элементы, стили применяются при наведении пользователем на элемент
    :active - ссылки, а также другие элементы, стили применяются при наведении пользователем на элемент

- Псевдоклассы пользовательского интерфейса: Относятся к элементам форм
    :disabled - используется для отбора и стилизации заблокированных для выбора и изменения элементов форм
    :enabled - отбирает не заблокированные для выбора и изменения элементы форм
    :checked - применяется для выбора и стилизации элементов <input type="radio">, <input type="checkbox">, а также элементов <option></option>, находящихся внутри элемента <select></select>
    :indeterminate - элементы радио и чекбокс могут быть включены или выключены пользователем

- Структурные псевдоклассы: позволяет отбирать элементы на основании информации, которая отражена в дереве документа и не может быть получена при помощи простых селекторов или их комбинации
    :root — элемент, являющийся корневым в документе
    :nth-child() — элементы на основе их индекса (в порядке очереди) внутри их родительского контейнера
    :nth-last-child() — дочерние элементы на основе их индекса внутри контейнера, при этом отсчёт идёт в обратном порядке, т.е. начиная с последнего элемента
    :nth-of-type() — элементы одного типа на основе их индекса внутри контейнера
    :nth-last-of-type() — элементы одного типа на основе их индекса внутри контейнера, начиная с последнего элемента к первому
    :first-child — элемент, который является первым дочерним элементом некоторого другого элемента
    :last-child — последний дочерний элемент элемента-контейнера

- Целевой псевдокласс :target

Примеры: для плавности анимации используется свойство transition: 0.5 all
  &:hover
    background-color: pink
    color: #fff
  &:active - срабатывает в определенный промежуток времени когда на кнопку нажали или держат нажатой
  &:nth-child(2n) - все четные элементы
    &:before - можно комбинировать псевдоклассы и псевдоэлементы
      &:after
      i
        стилизация для иконочного шрифта

outline: none - убирает рамку вокрук элемента во время active


Псевдоэлементы: 
- 

- &:before: Применяется для отображения контента до содержимого элемента, к которому он добавляется
- &:after: Используется для вывода контента после содержимого элемента, к которому он добавляется.

ВАЖНО!!! Когда вы используете псевдоэлементы :before и :after у них всегда должно быть свойство content: ''
Если его не будет, псевдоэлемент работать не будет, он просто не появится на странице


Как работь с иконками? Иконочные шрифты.
- Использование иконочных шрифтов это большой плюс к оптимизации


Иконочнй шрифт Font Awesome: 
- <i class="fa-brands fa-facebook-f"></i> : Иконка фейсбука

Т.к это иконочный шрифт, мы можем ее застилизовать также как обычнй элемент

i 
  color: #fff

Если выдает ошибку, можно использовать прием
- Сначало выравниваешь все по левому краю, затем с помощью TAB (табуляции выравниваешь обратно)

Также мы можем создававть свои иконочные шрифты и добавлять только те, которые нужны. А не скачивать все что есть

Если мы верстаем по сетке Bootstrap, то когда нам нужно использовать всю ширину строницы мы оборачиваем каждый блок в отдельный div
И используем flex чтобы выровнять как нужно


Адаптация проектов под различные устройства: 

Фиксированная верстка: (Fixed)
- При адаптиве снизу появляется полоса прокрутки т.к элементы не помещаются в ширину экрана. Это очень плохо
Испольлзуется очень очень редко и только там где сайты не имеют никакой адаптивности

Резиновая верстка: (Rubber)
- Это когда вы задаёте всему макету и отдельным его частям не фиксированную ширину, а эластичную — в процентах.
За исключением минимальной и максимальной ширины. Высоту в вебе в принципе не принято задавать — обычно она подстраивается под содержимое
Проценты считаются от родительского элемента в данном случае body. И занимают всегда % от экрана
Также при работе с картинками они будут сжиматься вместе сжатием страницы, и терять в качестве
Резиновая верстка подходит только к коким-то нескольким элементам

Адаптивная верстка: (Adaptive)
- Главное в адаптивной вёрстке — привязка к конкретным разрешениям и устройствам. 
Стили переключаются от одного брейкпоинта к другому, то есть у вас есть фиксированные макеты для iPad и iPhone, а то, что между ними вас не волнует.
Используя адаптивную верстку, наши блоки после определенного значения ширины уменьшились (адаптировались под определенную ширину эерана)
Используются Breikpoint и подкаждый такой поит пишутся свои стили. И когда разрешение экрана пользователя будет меньше чем версия ПК будут приминяться стиля под это разрешение

Отзывчивая верстка: (Responsive)
- Отличительной чертой подхода стало плавное изменение сайта, с ориентацией не на конкретные устройства, а на содержимое. 
То есть ваш резиновый макет хорошо выглядит не только на iPhone и iPad, но и в любой точке между ними.

Для Retina дисплеев нужно устанавливать большую плотность пикселей 2 или 3
Desktop (touch) - есть несколько устройств которые поддерживают тач события. Когда пальцем возим по экрану, и это работает как мышка
Mobil (no touch) - мобильные устройства которые не реагируют на действия пальцем

Также можно указать какое соединение с интернетом: No trottling
Также есть иконка которая позволяет переворачивать наше устройство (Rotate)
Также под меню есть полоска с разрешениями экрана. Как будет отображаться сайт на разных разрешениях

В проэкте как правило используется 3 последних вида т.к для каждого блока нужно нужен свой тип 

css правило @media: 
- правило которое помогает адаптировать элементы под определенные форматы

@media (max-width: 920px)
  .adaptive
      width: 300px
  .responsive
      width: 100%
      margin: 0

@media (min-width: 600px and (max-width: 600px) {

} -  создание коридора в 200px в которых будут применяться стили

@media (min-width: 600px and (orientation: landscape) {


Метатег viewport - тег отвечает за адаптивность сайте. 
Если его не указали, то адаптивность работать не будет
<meta name="viewport" content="width=device-width, initial-scale=1.0">

2 парметр: ширина нашего сайта будет такаяже как ширина устройства с которого мы просматриваем сайт

Типы верстки:
  1. Mobile First - когда мы сначала версткаем мобильную версию 
  2. Desktop First - когда мы сверстали сайт, а потом его уменьшаем 


Pixel Perfect верстка: 
- При версте когда вы не попадаете пиксель в пиксель могут влиять на это несколько факторов: 
  1. Верстка на Retina дисплее - плотность пикселей больше и соответсвенно что-то может поехать
  2. Не особо грамотный дизайнер, не особо правильно отрисовал макет и в Avacode не правельные интервали и межстрочное расстояние
И когда приходится делать Pixel Perfect приходится все эти огрехи исправлять 
  3. Часть элементов выравниваются не особо правильно

На практике такая техника встречается все реже и реже 


Адаптация при помощь Bootstrap: 
- Любой наш макет можно разбить на 12 колонок
Под каждое расширение есть свой тип колонок. Система колонок работает по восходящей
Все что ты назначил меньшему разрешению будет применяться на большие 

.col (<576px) - любой контен который мы поместили в такие колонки всегда будет равномерно распределятся по ширине контейнера
Если мы прошем .col-4 что наш контент делится на 4 колонки, то он будет делится на 4 колонки на всех расширениях

.col-sm (≥576px) -

.col-md (≥768px) -

.col-lg (≥992px) -

.col-xl (≥1200px) - 

.col-xxl (≥1400px) -

Чтобы задать адаптивность элементам каждому нужно прописывать количество колонок на каждом разрешении
<div class = "box col-4 col-sm-4 col-md-4 col-lg-4 col-xl-4 col-xxl-4">Какой-то контент!!!<div>

Если например на маленьких разрешения выглядит также как на средних, и тд в таком случае нам не нужно прописывать все классы
Нужно прописывать только те, на разрешении которых сайт меняется

Также в дополнение к классу row мы можем добавлять свойства выравнивания, и все наши элементы будут выравниваться
vertical-align-start - vertical-align-center - vertical-align-end: <div class="row vertical-align-start">

Также мы можем добавлять горизонтальное выравнивание к классу строки row: <div class="row justify-content-start">
justify-content-start - justify-content-center - justify-content-end


Локальные ссылки и favicon: 
- Чтобы можно было переходить по меню лендинга на разные разделы мы используем локальные ссылки (якорные ссылки) 
Каждому блоку мы присваиваем свой id с названием этого блока. И далее в атрибут href="require" мы вставляем id с названием блока
Тем самым мы попадем в начало блока

favicon - Favicon играет важную роль в веб-приложениях. Он может улучшить внешний вид сайта в выдаче, повышает узнаваемость вашего сайта, помогает пользователю быстро найти необходимую страницу в закладках и вкладках.

Кроме того, пользователь может добавить страницу вашего сайта на главный экран телефона или сохранить как веб-приложение
В таком случае с помощью favicon можно быстро найти сайт среди большого количества других приложений

Перед продакшеном нужно дорабатывать UX взаимоедйствие элементов с пользователем
Где-то добавить расстояние, посмотреть как будет выглядеть на разных экранах и т.д
Продумать какие действия пользователь может совершить, что он может не понять? Что не удобно работает и тд?

Хорошей практикой считается убирать лишние hover эффекты там где они не нужны на мобильных устройствах

Чтобы использовать сверстанный сайт можно создать домен на Github Pages
Существует только в единственном экземпляре


Система контроля версий Git и сервис GitHub
- git init команда чтобы гит следил за изменениями в папке

После инициализации репозитория нужно настроить систему git
Как правило на проектах работает команда и чтобы понимать какие изменения кто внес нужно представится
- git config --global user.name "Maksim"
- git config --global user.email example@gmail.com


Мы можем конфигурировать файлы как локально так и глобально (поставим настройки на весь пк)
Если мы сделали локальлные настройки, то глобальные действовать не будут
--local (для установления локальных данных)

Вторым обязательным конфигом является емаил

У git репозитория есть 3 состояния файлов:

  - Первое состояние когда файлы просто созданны
Мы создали какой-то файл и он просто лежит в проекте и ничего с ним не происходит

  - Второе состояние когда git следит за какими-то определенными файлами
Когда такое происходит они попадают в индекс

  - Третье состояние когда git создал контрольную точку к которой можно будет вернуться "commit"

Чтоюы посмотреть какой статус у репозитория 
git status

Чтобы добавить файлы в индекс
git add -A
Что такое дефис -A? (All) Мы говорим что все файлы не добавленные в индекс они туда добавятся

После второва состояния мы можем закомитить отслеживаемые файлы
git commit -a -m"message"

-a (обозначает все файлы)
-m(это описание, где кратно говорим что сделали на этом этапе)

После отправления коммита если мы напишим git status, то увидим что git не следит не за какими файлами, и в индексе ничего нет

Если мы хотим посмотреть какие были коммиты. Когда они были выполнены, кем выполены,афтора 
git log

В данном случаем мы работали в локальном репозитории
Чтобы создать в глобальнольном репозитории мы создаем репозиторий на github
Также мы можем создать файл Readme в котором можем описать проект


git remote add origin https://...ссылка...

remote add - добавляем удаленный репозиторий
origin - название репозитория
ссылка - url к этому репозиторию 

Теперь наш локальный репозиторий связан с удаленным 
Если мы заходим что-то оправить в удаленный репозиторий нужно использовать команду: 
git push -u origin master

push - для того чтобы запушить изменения
origin - название репозитория в который пушим 
master - это ветка
-u - ключ говорит что дальше все push из локального репозитория по умолчанию будут push в git push -u origin master

После запуска команды у нас может пройти какое-то определенное время особенно если файлов довольно много
Мы видим техническую информацию где в конце нам говорят, что все прошло хорошо

После добавления в индекс все фалы можно запушить

У нас есть команда для работы с ветками 
git branch -M main 

main - это главная ветка (в обновлении заменили master на main)

На большом проекте есть большое кол-во разработчиков которые реализуют разные фичи
И у каждого есть ветка для того чтобы работать с нужным функционалом, а потом пушить в главную ветку


Как работать с GitHub с разных компьютеров, gitignore и Git Kraken

1. Мы создаем отдельную папку для нового репозитория. 
  - Чтобы работать с файлами нужно их клонировать в новый репозиторий
cd.. - позволяет выйти из папок

Переходим через тепрминал в новую паку cd work
git clone https://...ссылка... project_2

И далее написать название папки в которую все будет складываться

Если ты клонируешь какой-то репозиторий, то он сразу будет связан с каким-то удаленным 
Локальный репозиторий который мы создали он уже связан с удаленным 

Чтобы получить изменения с удаленного репозитория 
git pull

Тем самым измененые файлы сразу же обновляются

Самые частые ошибки новичков.
  - Например на удаленном репозитории могли произойти какие-то изменения, другой разработчик запушил какие-то новые данные,
либо сами вручную создали какой-то файл. Допустим вы что-то сделали в своем проекте добавили в индекс и закомители.
И на данном этапе заыбли что что-то поменяли на удаленном репозитории. То когда пытаешься запушить выходит ошибка

Гит говорит что у вас в репозитории есть более новая версия проекта, что нужно сначало провести команду git pull
И тогда уже коммитить. Если на удаленном репозитории были какие-то измененния всегда нужно писать git pull

Появляется тех информация где говорится что происходит слияние 2 версий проекта

:wq! 
Merge - слияние веток

Такая ситуация может происходить только при отличии локального репозитория от удаленного


Игнорирование файлов при работе с git: 
  - Перенос или создание файла .gitignore

Когда мы будем работать в реальных проектах часть файлов которые находятся внутри мы не хотим push в репозиторий
Чаще всего это рабочие файлы которые позволяют нашему проекту правильно запускаться, файлы настроек, то что не нужно выкладывать
Пример: Папка node_modules


Методология БЭМ: Блок - Элемент - Модификатор
  - Технология была придумана Яндекс и она использует подкомпонентный подход для верстки

И верстальщики и программисты всегда борются за оптимизацию своей работы и очень часто происходит когда из 
проекта в проект внутри самого проекта используем copy_paste (копировал вставил)
И как раз чтобы не выполнять такую рутинную работу и была придумала технология БЭМ


Эта технология позволяет нам разделять интерфейс на независимые блоки

Блок - функционально независимый компонент страницы, который может быть повторно использован

Особенности: 
  - Название блока характеризует смысл (что это?), а не состояние 
  - Блок не должен влиять на свое окружение, т. е. блоку не следует задавать внешнюю геометрию (в виде отступов, границ, влияющих на размеры) и позиционирование
  - В CSS по БЭМ также не рекомендуется использовать (стилизовать по селекторам и тегам) селекторы по тегам или id.

Таким образом обеспечивается независимость, при которой возможно повторное использование или перенос блоков с места на место.  

Принципы работы с блоками
  - Блоки можно вкладывать друг в друга
  - Допустима любая вложенность блоков


Элемент - составная часть блока, которая не может использоваться в отрыве от него

Особенности: 
  - Название блока характеризует смысл (что это?), а не состояние 
  - Структура полного имени элемента соответствует схеме: имя-блока__имя-элемента. Имя элемента отделяется от имени блока двумя подчеркиваниями (__).

Cуществует зависимость элемента от блока. Элемент не может существовать отдельно от блока

Принципы работы с элементами: 
  - Вложенность
    - Элементы можно вкладывать в друг друга
    - Допустима любая вложенность элементов
    - Элемент — всегда часть блока, а не другого элемента. Это означает, что в названии элементов нельзя прописывать иерархию вида block__elem1__elem2

  - Принадлежность
    - Элемент — всегда часть блока и не должен использоваться отдельно от него.

  - Необязательность
    - Элемент — необязательный компонент блока. Не у всех блоков должны быть элементы.

Когда создавать блоки, а когда элемент?
  - Если вы понимаете что элемент который вы создаете будет переиспользоваться на странице, то создаете блок
  - Если вы понимаете что та структура будет зависима от блока в котором он находится, то создаем элемент


Модификатор - сущность, определяющая внешний вид, состояние или поведение блока либо элемента.

Особенности: 
  - Название модификатора характеризует внешний вид (какой размер? какая тема?), 
состояние (чем отличается от прочих?) и поведение (как ведет себя?, как взаимодействует с пользователем)
  - Имя модификатора отделяется от имени блока или элемента одним подчеркиванием (_)

Типы модификаторов: 
  - Булевый
    - Используют, когда важно только наличие или отсутствие модификатора, а его значение несущественно.
    имя-блока__имя-элемента_имя-модификатора (если сущность пишется из двух слов, она пишется через тире)
  
  - Ключ значение
    - Используют, когда важно значение модификатора. Например, «меню с темой оформления islands»: menu_theme_islands
    имя-блока__имя-элемента_имя-модификатора_значение-модификатора

Принципы работы с модификаторами: 

  - Модификатор нельзя использовать самостоятельно
С точки зрения БЭМ-методологии модификатор не может использоваться в отрыве от модифицируемого блока или элемента. 
Модификатор должен изменять вид, поведение или состояние сущности, а не заменять ее.

  - Микс
    - Прием, позволяющий использовать разные БЭМ-сущности на одном DOM-узле.
Чтобы задавать позиционирование блоку через модификатор

Миксы позволяют:
  - совмещать поведение и стили нескольких сущностей без дублирования кода;
  - создавать семантически новые компоненты интерфейса на основе имеющихся.

Анимация на сайтах с помощью CSS3: 
  - Любая CSS анимация строится на ключевых кадрах
Это значит что каждую анимацию мы можем расписать по отдельным фрагментам, по отдельным кадрам которые будут показываться пользователю
Во внутрь этих кадров можно записывать любые css свойства и их значения. Как они будут изменяться в динамике 

@keyframes имя анимации { список правил }

@keyframes - для начала прописывается директива. Говорит о том что сейчас мы будем прописывать какую-то анимацию

В правилах нужно прописать ключевые кадры по которым будет работать эта анимация
В анимации есть 2 самых важных кадра. Это начальный и конечный 

from {} - из какого состояния она будет начинаться
to {} - последний кадр в котором анимация закончится

В промежутках между началом и концом мы можем прописывать промежуточные кадры
Как правило кадры прописываются в процентах 

Есть 2 важных правила без которых анимация работать не будет
  - aniamtion-name - это название анимации. Как мы называли анимацию в отдельном файле
  - animation-duration - сколько будет выполнятся анимация

Так же для работы с анимацией есть специальные библиотеки Animate.css

Валидация сайта 
  - проверка HTML файла на соответсвие современным стандартам
Если валидатор нашел какае-либо несоответствие, то сайт считается не валидным

Внегласное правило валидации, что блок section должен всегда содержать заголовок
Если мы создаем ul, то внутри может быть только тег li, отдельно ссылки быть не может


CSS Grid. 
  - Это новая модель для создания шаблонов которая создана для создания двух мерных макетов

Чтобы создать сетку или грид нам понадобится написать свойство display: grid;
Сетка всегда состоит из 2 элементов, это строки и колонки. 
У нас должны быть как вертикальные так и горизонтальные линии которые будут формировать сетку

Для того чтобы в Grid создать колонки нужно использовать свойство grid-template-columns: 
И дальше задаем сколько колонок мы хотим определить, причем сразу же мы можем прописать их размеры
Например пропишем что у нас будет 3 колонки по 200px. У нас будет 3 колокнки каждая из которых будет занимать 200px

grid-template-columns: 200px 200px 200px

Также мы создаем строки. Для этого используется свойство grid-template-rows: 

свойство grid-template-rows: 60px 60px 60px;

Грид элементы иногда называют треками. Это какая-то область которая ограничена всеми линиями

column-gap: 20px; - Свойство ипользуется для создания разрывов между колонками (расстояние между колонками)
row-gap: 20px; - Свойство использует для создания разрывов между строками (расстояние между строками)

Есди в обоих свойствах используется одинковые размеры например 20px, то мы можем объеденить в одно свойство gap: 20px;

Также чтобы создавать как колконки так строки можно использовать одно большое свойство

grid-template: 200px 200px 200px | 60px 60px 60px;

Через слэшь мы пишем то, что относилось к строкам
!!!!Гриды это не замена флексам. Это немного разные технологии, но css grid больше подстроен чтобы создавать некоторые шаблоны для проектов
В новом проекте можно комбинировать как css grid, так и flexbox. Одна технология будет формировать каркас, а вторая выравнивать элементы


Еденицы гибкости(fr) и repeat()
  - Используя fr элементы будут сами подстраиваться без всяких расчетов и указаний

grid-template-columns: 1fr 2fr 1fr

В таком случае наш контейнер будет разбит на 4 еденицы
Мы сами велины не прописываем. Сетка за нас сама просчитывает сколько нужно места для элемента

grid-template-rows: 1fr 1fr 1fr;

Тоже самое что и колонками

repeat() - функция генерирует определенные значения 
grid-template-rows: repeat(3, 1fr);

Первое что нужно указать это сколько раз мы будем повторять то, что будет идти после запятой
У нас будет 3 колонки, поэтому мы ставим 3

Второе через запятую написать что мы будем повторять


Явные и неявные гриды: 

  - Явные - те которые в ходят в сетку которая описана двумя свойствами grid-template-columns: 1fr 2fr 1fr, grid-template-rows: repeat(3, 1fr);
  - Неявные - вся остальная сетка. Браузер создает ее автоматически: grid-auto-columns: 1fr 2fr 1fr, grid-auto-rows: repeat(3, 1fr);

Неявные гриды по умолчанию будут расти всегда вниз

Функция minmax() и масштабирование треков:  

  - функция позволяет определять максимальное и минимальное значение какого-то элемента

grid-template-columns: repeat(3, minmax(100px, 300px))
1. Первое значение это минимальная высота элемента/ширина
2. Второе значение максимальное значение

Теперь колонки будут занимать максимальную ширину, т.к это div и они занимают всё доступное пространство. Они всегда принимают максимальное значение
Вторым парметром мы хотим сказать, что если вдруг в этот элемент у нас приходит контент который растягивает его больше,
чем первоначальное значение, то наш элемент будет подстраиваться под этот контент поэтому прописываем auto

grid-template-columns: repeat(3, minmax(100px, auto))

Теперь каждый элемент стал по 100px в высоту. Это говорит о том что если внутри элемента нет контента он будет занимать минимальную высоту в 100px
Это подход применяется для того чтобы подготовить элемент для переполнения контентом
Т.к у элемента в первом варианте фиксированная высота, если контента будет больше чем высота, то контент вылезет за рамки элемента

Чтобы этого не происходило, используется свойство auto которое автоматически подстраивается под кол-во контента

Свойство auto-fill - автоматически заполняет доступное пространстов элементами, если они помещаются на экране
Когда мы используем auto-fill в конце остается пустое место. Оставляет пустое место под будующие элементы

Свойство auto-fit - работает точно также. Отличие в том что стягивает все пустые треки в конце его размещения
Позволяет не оставлять место. Элементы растягиваются на протяжении всего grid-container

grid-template-columns: repeat(auto-fit, minmax(100px, auto))


Свойство grid-auto-flow: row; - говорит неявным гридам, куда будут добавляться элементы 


Позиционирование треков: 
  - 

Grid Liners - Формируют сетку. Имеют числовой индекс (1, 2, 3, 4 и тд) и сетка их запоминает. Отсчет начинается с 1

Column Line - колоночная линия
Row Line - строковая линия

Данная технология работает для каждого элемента отдельно

#first {
  grid-column-start: 1;
  grid-column-end: 3;
}

#second {
  grid-row-start: 1;
  grid-row-end: 3;
  grid-column-start: 1;
}


grid-column-start: 1; - чтобы наш элемент начинался с 1 линии по колоночной оси
grid-column-end: 3; - на каком этапе будет заканчиваться наш элемент. Элемент будет заканчиваться на 3 линии

Гловное представлять сколько колонок в вашей сетке, и просто переменщать по линиям по этим позициям
Можно не указывать конечную точку, потому что если ее не указать, то по умолчаю элемент будет захватывать только один трек
Только один элемент который ему доступен. Элементом может быть как колонка, так и строка

Сокращенные варианты свойств: 
  - 

#first {
  grid-column: 1 / 3; - пробелы можно не ставить. Никакой разницы нет
  grid-row: 1 / 3; 
}


Выравнивание треков:  
  - Выравнивание гридов можно производить в таком же формате что и flexbox
Есть главная ось, и поперечная


Grid Area и подсетки. Адаптация гридов
  - Грид области


















































































*/
