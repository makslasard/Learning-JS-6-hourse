/*
Теория тестирования: 
    - это код который проверяет работает ли код написанного приложения правильно. Отвечает ли он бизнес ожиданиям

Если вы сделали фичу которая копирует какие-то данные, то она реально должна их копировать, а не удалять например
Когда мы говорим о соответсвии кода каким-то бизнес ожиданиям необходимо ввести 2 важных понятия:

    - TDD (Test Driven Development) - это написание тестов, а потом на основании написанных тестов задание логики

    - BDD (Behaviour Driven Developmen) - это написание тестов, предпологается описание тестировщика или бизнес аналитиком пользовательских сценариев. Т.е описание поведения 

Типы тестирования: Пирамида тестирования

1. Unit Testing
    - Самый простой вариант тестирования. Когда по сути происходит проверка логики инкапсулированного модуля или юнита
В нашем случае, это полное тестирование логики инкапсулированного компонента. Данный вариант тестирования самый быстрый и самый простой
И не требует разворачивания каких-то дополнительных окружений 

2. Integration Testing
    - Проверяется взаимодействие созданного модуля с другими. Т.е не сломалась ли новая логика или что-то за ее пределами
Этот вариант сложнее и требует больше знаний в области тестирования. Плюс установки и настройки среды тестирования

3. End-to-end (E2E)
    - Самый сложный и самый надежный. Но в тоже время самый объемный и требующий большого кол-ва времени
Проверяется работа всего приложения и фактически описанные ранее бизнес кейсы


Когда мы начинаем работать с Unit - тестированием или как его еще называют модульным тестированием первое понятие с которым
мы столкнемся это STUB & MOCK. Оба определения связаны с подменой данных 

- STUB & MOCK - это объекты которые создаются и используются в замен реальных объектов с которыми взаимодейтвует модуль в процессе своей работы

Stub - это статичный объект который имеет структуру валидного ответа. Не имеет значения какие вводные данные мы даем ответ всегда будет один и тот же

initialize => exercise => verify
    
Mock - это настраиваемые объекты которые позволяют задать ожидание в виде своего рода спецификации вызовов которые мы планируем получить

initialize => set expectations =>exercise => verify

Валидный тест - это один тест одна проверка

Unit тестирование предпологает инкапсуляцию модуля и проверку его внутренней логики 
Даже у компонента есть свои свойства и методы которые он принимает с наружи ввиде props
Какие-то внешние утилиты, пакеты и тд. Именно эти данные будут подменяться

Требование к тестированию:
    - Правило 1: 1 тест , 1 проверка

Не нужно делать 1 общий тест и проганять 100500 разных случаев
Для каждого действия должен быть свой индивидуальный тестировочный кейс

Ключевые слова: describe, it 
    Это посути обертки внутри которых мы описываем ожидание. После чего создаем тест
    Тест должен быть локаничным максимально простым в понимании и чтении

Понятие coverage - покрытие кода тестами. В реальных проектах цифра должна быть не ниже ~90%
100% - это не достижимое число. В идеале нужно 90% и выше

Все файлы в которых содержаться тесты будут заканчиваться на .spec.js - это обязательное условие


Важно:

    - Тестирование может показать наличие деффектов в программе, но не доказать их отсутвие
Т.е написав тест мы проверяем конкретную фукнциональность. Если тест сломался, то тогда мы знаем 
    что эта конкретная фукнциональность не работает. 
Если тест не сломался, то говорить о том что внутри нет других деффектов мы не можем

Науный подход в программировании - когда мы изучаем нашу программу с помощью тестов на не правильное поведение,
    но этот подход не может гарантировать отсутствие деффектов. 

Корректность программы доказываеться через математическую модель, математические методы
А через тесты мы лишь проверяем основные моменты которые нам интресны. 
Тесты позволяют улучщить качество работы программы, и многие хорошо протестированные программы можно
    назвать условно корректными т.к проверены основные действия программы и такие программы на практике 
    ломаются гораздо реже

Покрытие - это когда все возможные варианты программы покрыты тестами

    - покрытие операторов
    - покрытие условий
    - покрытие путей
    - покрытие функций 
    - покрытие вход/выход
    - покрытие значений параметров

Тестировать нужно основную функцональность т.к комбинации данных могут увеличиваться и закрыть все их 
    тестами не предстовляется возможным 

Покрытие кода - не цель
Нормальное покрытие 80% кода

3 варианта тестирования:
    - тестирование внутри границ 
    - тестирование на границах
    - тестирование вне границ
    
Установка окружения:

    install ts-node ts-jest jest @types/jest mockdate --save-dev


Тестовый двойник - это общий термин для объектов, которые мы используем, чтобы заменить реальный объект

Существует 4 типа двойников:
    - Пустышки (dummy)
    - Имитации (fake)
    - Заглушки (stubs) - тестирование состояния
    - Подставные объекты (Mock) - тестирование поведения

Инициализация config для нашего теста: ts-jest config:init

У любого теста выполняется 4 шага:
    1. Setup - когда мы устанавливаем значения необходимые во всем тесте в рамках всех 
запускаемых тестов. Обычно включает инициализацию дефолтных состояний либо констант 

Он может быть выполнет как в качестве отдельного метода который будет называться setup, 
    или как часть выполняемой функции

Метод запуска тестов describe()

describe() - это функция которая объеденяет в себе набор тестов с общей логикой. 
    Она определяет фокус нашего тестирования. Мы внутри тестируем либо класс либо набор классов 
    связанных с одной функциональностью 

И рассматриваем в виде множества тестов которые рассматривают нашу функциональность с разных точек зрения

describe('Age', () => {

})

Состоит из 2 параметров: 1. Age - это название нашего класса который мы будем тестировать


*/
import Age from './ex1'
import { set, reset } from 'mockdate'

describe('Age', () => {
    const data = '2020-09-26';
    const timestamp = new Data(data).getTime()
    let myAge: Age;

    beforeEach(() => {
        set(data)
    })


})