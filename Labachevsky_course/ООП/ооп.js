/*
Парадигма ООП: Основные понятия

1. Объект
2. Класс
3. Экземпляр класс (инстанс)
4. Наследование 
5. Инкапсуляция
6. Полиморфизм
7. Абстракция 
8. Интерфейс
9. Композиция
10. Агрегация

Процедурное программирование (Функциональный подход в JS) - подход который сводится к написанию функций

    Приложение написанное в процедурном подходе проходит через 3 основный этапа:
        - Получение аргументов для работы
        - Выполнение функци (или процедур)
        - Возвращение результата

Пример:
    const isPalidrome = str => {
        str === str.split('').reverse().join('')
    }

    isPalidromne('тест') // false
    isPalidromne('шалаш') // true

Проблемы такого подхода:
    - Большое количество кода
    - Трудности в чтении и анализе логики
    - Сложность в организации отдельных модулей и структур
    - Сложность в декомпозиции и разделении логики

В результате появилось объектно-ориентированное программирование (ООП)
    - Данный подход хорошо справлялся с описанными проблемами


Объектно-ориентированное программирование (ООП)
    - оснавная идея в том что любую структуру в приложении можно представить в виде объекта или класса
с своими свойствами и методами. Эти свойства и методы можно расширять, наследовать, изменять, передовать и т.д


Объект:
    - это элементарная еденица в ООП которая представляет из себя набор свойств. И каждое свойство состоит из имени и 
значения ассоциированным с этим именем.

Пример:

const bmvAuto = {
    name: 'BMW',
    model: 'X6',
    year: '2021',
    getAutoType() {
        return `${this.name} ${this.model} - ${this.year}`
    }
}

Объект давольно удобная структурная еденица, однако он не такой гибкий как хотелось бы.
Поэтому дополнительной надстройкой над объектом можно назвать класс


Класс:
    - в ООП класс это расширяемый шаблон кода для создания объектов. Которые устанавливают в них начальное значение и реализацию поведения

constructor(name, model, year) - это особый метод который вызывается в момент инициализации класса и создает свойства
Т.е подготавливает объект для дальнейшего использования. 

В данный класс мы передаем 3 параметра. Далее эти значения можно присвоить объекту. Который будет создан на основании класса
После чего они станут свойствами. Ключевое слово this в данном случае нужно для определения контекста


Экземпляр класса (инстанс)
    - если объект создается на основании класса, то он называется экземпляром класса или инстансом

Для того чтобы создать объект класса используется с ключевым словом new
На основании одного класса можно создать сколько угодно экземпляров

Пример:

class Auto {
    constructor(name, model, year) {
        this.name = name
        this.model = model
        this.year = year
    }
    getAutoType() {
        return `${this.name} ${this.model} - ${this.year}`
    }
}
const bmwAuto = new Auto('BMW', 'X6', 2021)
const audiAuto = new Auto('Audi', 'Q7', 2020)
const teslaAuto = new Auto('Tesla', '3', 2019)

Каждый из экземпляров это будет отдельный объект с своими свойствами и унаследованными от класса методами


3 основные концепции ООП:
    - Наследование 
    - Инкапсуляция 
    - Полиморфизм


Наследование - это создание новых классов на основе существующих

Классы могут наследоваться. Т.е на основании одного класса можно создать еще один
В котором существующие свойства и методы будут унаследованы, но по желанию их можно переопределить

Если нам нужно переопределить свойства, для этого нам нужен метод конструктор
В данном случае создавать конструктор нужно добавляя ключевое слово super()
Использование данного слова запустит механизм наследования конструкторов 

Это говорит о том, что сначала будет запущен конструктор родителя, а затем уже дочерний

Пример:

class TeslaCar extends Auto {
    constructor(name, model, year) {
        super(name, model, year)
        this.name = name
        this.model = `${model} Model`
        this.year = year
    }
    getCarModel() {
        return this.model
    }
}
const teslaAuto = new Auto('Tesla', '3', 2019)

У TeslaCar будут доступны свойства и методы объекта родителя 


Инкапсуляция:
    - представляет сокрытие состояния объекта от прямого доступа из вне

Проблема в том что все публичные данные могут быть намерено или ошибочно изменены, 
что может привести к неправильному выполнению программы

Для начала внутри класса определяется свойства с которыми он будет работать
Значение vin не будет передаваться снаружи, а будет генерироваться автоматически. 
Если мы попытаемся обратиться к свойству снаружи, то получим ошибку

Тем самым свойство vin будет доступно только в классе auto
Чтобы воспользоваться приватным методом снаружи, нужно воспользоваться getter который будет возвращать это приватное значение

Таким образом мы можем защитить наш класс от неконтралируемых изменений
А доступ к свойствам реализовать с помощью дополнительных методов

На реальных проектах доспут к свойствам и методам класса стараются по максимому закрывать
Выставляя наружу только те методы которыми можно безопасно манипулировать с установкой и получением этих приватных значений

Пример:

class Auto {
    public name: string,
    public model: string,
    public year: number,
    private vin: number

    constructor(name: stirng, model: string, year: number) {
        this.name = name
        this.model = `${model} Model`
        this.year = year
        this.vin = (new Date().getTime())
    }
    get vinNumber() {
        return this.vin
    }
}


Полиморфизм: (poly - много, morphism - изменение формы или поведения)
    - используется когда нужно чтобы интерфейс функции был достаточно гибким чтобы принимать разные типы или кол-во параметров
    Одинаковая работа с разными формами

Кроме того на основании изменения типов параметров логика функции могла изменятся
Это способность вызывать один и тот же метод для разных объектов и каждый объект на это действие будет реагировать по разному

В каждом из классов будет своя реализация метода. Итоговая возвращаемая строка у каждого класса будет своя


Пример:

class BmwCar extends Auto {
    getAutoType() {
        return `${this.name} ${this.model} - ${this.year}`
    }
}

class AudiCar extends Auto {
    getAutoType() {
        return `${this.name} ${this.model} - ${this.year}`
    }
}   

class TeslaCar extends Auto {
    getAutoType() {
        return `${this.name} ${this.model} - ${this.year}`
    }
}

const bmwAuto = new Auto('BMW', 'X6', 2021)
const audiAuto = new Auto('Audi', 'Q7', 2020)
const teslaAuto = new Auto('Tesla', '3', 2019)

const autos = [bmwAuto, audiAuto, teslaAuto]

const getAutoTypes = (autos) =>
    autos.map(autos => autos.getAutoType())

const autoTypes = getAutoType(autos)


3 понятия работают вместе, и тесно связаны друг с другом


Интерфейс
    - определяет свойства и методы который объект или класс должен реализовать

Однако внутри себя интерфейс не содержит никаких реализаций
readonly - только для чтения, и попытка их изменить вызовет ошибку

Интерфей не может создавать экземпляры
const teslaAuto = new Auto('Tesla', '3', 2019)

На основании интерфейса можно создать класс

В классе наследнике должны быть реализованы все свойства и методы которые описаны в интерфейсе

Пример:

interface AutoFactory {
    readonly name: string,
    readonly model: string,
    year: number

    getAutoType(): string
}

class Auto implements AutoFactory{
    public name: string,
    public model: string,
    public year: number,

    constructor(name: stirng, model: string, year: number) {
        this.name = name
        this.model = `${model} Model`
        this.year = year
        this.vin = (new Date().getTime())
    }
    getAutoType() {
        return `${this.name} ${this.model} - ${this.year}`
    }
}


Абстракция:
    - это способ создания простой модели которая содержит только важные свойства с точки зрения контекста приложения из более сложной модели

В TypeScript есть специальное слово abstract

Метод содержит ключевое слово abstract т.к не содержит реализации

Особенность наследования от абстрактного класса заключает в том что, если в абстрактном классе
нет реализации метода, то реализация обязательно должна быть описана в наследнике

А если в абстракции реализация есть, то класс наследник наследует ее от обстракции 

abstract class Auto {
    readonly name: string,
    readonly model: string,
    year: number

    abstract getAutoType(): string

    getAutoModel(): string {
        return this.model
    }
}


Композиция:
    - это подход при котором одни классы или объекты содержат в себе другие 

Особенность заключается в том что, что эти вложенные сущности не могут существовать вне корневого класса 

class Engine {
    start() {
        return 'Engine is started'
    }
}

class Wiring {
    start() {
        return 'Wiring is started'
    }
}   

class FuelPump {
    start() {
        return 'FuelPump is started'
    }
}

class Car {
    constructor() {
        || Composition
        this.engine = new Engine()
        this.wiring = new Wiring()
        this.fuelPump = new FuelPump()
    }
    start() {
        || Delegation
        this.engine.start()
        this.wiring.start()
        this.fuelPump.start()
    }
}

Описанные классы деталей создаются именно при инициализации класса Car
Они создаются где-то снаружи и передаются в виде параметров при инициализации. Такой подход назыает композицией
Метод start() который будет запускать аналогичные методы у каждой из деталей


Агрегация:
    - 

class Engine {
    start() {
        return 'Engine is started'
    }
}

class Wiring {
    start() {
        return 'Wiring is started'
    }
}   

class FuelPump {
    start() {
        return 'FuelPump is started'
    }
}

class Autopilot {
    navigate() {
        return 'Navigation is started'
    }
}

class Car {
    constructor(autopilot) {

        this.engine = new Engine()
        this.wiring = new Wiring()
        this.fuelPump = new FuelPump()
        this.autopilot = autopilot
    }
    start() {

        this.engine.start()
        this.wiring.start()
        this.fuelPump.start()
    }
}

Класс autopilot при передаче как параметр становится независимым и может использоавться в других классах

Основная идея агрегации заключается в том что, классы которые используются внутри являются независимыми,
и передаются снаружи через параметры конструктора. Это главное отличие агрегации от композиции





*/