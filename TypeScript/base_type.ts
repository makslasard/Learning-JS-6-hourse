// Базовые типы в TypeScript
const isFetching: boolean = true; // тип boolean
const isLoading: boolean = false;
// Типы мы указывает перед присвоением и через двоеточие : . 
const init: number = 42; // тип number
// init = '' - ошибка!!!!
// ВАЖНО!!! если мы поменяем const на let, и попробуем переопределить переменную , то typescrpipt выдаст ошибку
const float: number = 4.2;
const num: number = 3e10;

const message: string = 'Hello world!'; // тип string

const numberArray: number[] = [1, 1, 2, 3, 5, 8, 13];
// Чтобы объявить массив нужно к типу данных добавить квадратные скобки []. 
const numberArray2: Array <number> = [1, 1, 2, 3, 5, 8, 13];
// Второй вариант объявления переменной запись называеться дженерик
// Указывает в треугольных скобках из чего состоит класс или объект
const strArray: string[] = ['Hello', 'World'];

// Tuple

// Идея заключается в том, что мы также создаем массив состоящий из разных типов данных 
const contact: [string, number] = ['Maksim', 12344];

// Any 

let variable: any = 43;
// .... - проходит время, и мне нужно переопределить переменную
// По умолчанию видно что TypeScript не дает этого сделать 
variable = 'New Sring!'
// тип any обозначает динамический тип. Использование any равноценно отказу от проверки типов для переменной.

// Функции

// Void

function sayMyName(name: string): void {
    console.log(name);
};
// Если мы вызовем функцию, она нам ничего не вернет и мы можем явно указывать возвращаемый тип данных у функции
// Тип void - означает что функция при вызове нам ничего не возвращает
sayMyName('Хайзенберг');

// Never 

// never - служит для указания того, что какие-либо операции никогда не будут выполнены.

// Стоит указывать в двух случаях: 
// 1. Когда функция либо возвращает нам ошибку и никогда не завершает свое выполнение , либо она постоянно что либо делает
function throwError (message: string): never {
     throw new Error(message);
}  

/*function infinite(): never {
    while(true){
    }
}*/

// Type

// Специальная конструкция которая позволяет нам создавать свои собственные типы
type Login = string

const login: Login = 'admin' // Переменная с типом логин
// Это иногда удобно для работы, т.к какие-то именнованые типы дают больше понимания что происходит
// Также можгно создавать типы с несколькими типами
type ID = string | number // Прямая палка это или. Или string или number
const id1: ID = 1234
const id2: ID = '1234'

type someTypes = string | null | undefined


// Interface

// Мы создаем некоторый тип который в основном служит для объектов, классов где мы указываем какие поля, функции и какие элементы должны присутствовать у этих объектов
// Интерфейсы не во что не компилируются, нужны только на этапе разработки 
interface Rect {
    readonly id: string
    color?: string // Необязательный параметр знак ?
    size: {
        width: number
        height: number
    }
}
// Модификатор readonly - который позволяет на этапе конпиляции определить что данные переменные никак не будут перезаписаны
// Мы сразу можем сказать что данное поле будет только для чтения, мы не сможем его изменять для этого используется модификатор readonly
// С помощью знака вопроса мы говорим что этот тип не обязателен. 
// Когда мы создали интерфейс мы можем содавать объекты с  типом rect
const rect1: Rect = { // Переменная подчеркивается так так не реализован функционал интерфейса
    id: '1234',
    size: {
        width: 123,
        height: 1234
    },
    color: '#ccc'
}

const rect2: Rect = { // Переменная подчеркивается так так не реализован функционал интерфейса
    id: '1234',
    size: {
        width: 123,
        height: 1234
    }
}
rect2.color = 'black'
// В данном случае какбы изменяется константа т.к 
// В конечном итоге мы все равно работаем в JS то константы если это объект или массив мы можем изменять внутренние свойства и состояние
const rect3 = {} as Rect

// Наследование интерфейсов

interface reactWithArea extends Rect { // extends - это наследование от интерфейса
    getArea: () => number // Интерфейс наследует свойства у Rect и добавляет дополнительные и обязательные свойства
}

const rect5: reactWithArea = { 
    id: '1234',
    size: {
        width: 123,
        height: 1234
    },
    getArea(): number {
        return this.size.width * this.size.height
    }
}

// Взаимодействие интерфейсов с классами 

interface IClock {
    time: Date,
    setTime(date: Date): void
}

class Clock implements IClock { // Класс имплементируется и должен воссоздать методы IClock
    time: Date = new Date()
    
    setTime(date: Date): void {
        this.time = date
    }
}
// Интерфейсы могут быть реализованы не только объектами, но и классами. Для этого используется ключевое слово implements
// implements - это ключевое слово для реализации функционала interfase через class

// Взаимодействие интерфейсов с объектом у которого большое кол-во динамических ключей
interface Styles {
    [key: string]: string
}
// В квадратных скобках мы указываем тип ключа, а как значение будет string

const css: Styles = {
    border: '1px solid black',
    marginTop: '2px',
    borderRadius: '5px'
} // Мы не можем перечислить все css свойство, т.к это будет не эффективно

// Enums

// Это конструкция, состоящая из набора именованных констант, именуемая списком перечисления и определяемая такими примитивными типами, как number и string
// Вспомогательная сущность которая позволяет лучше структурировать код если присутстуют однотипные элементы
// Есть 2 типа записи 

enum Membership {
    Simple,
    Standard,
    Premium
}
// По умолчанию если мы задаем enums таким образом, то они присваивают значение 0, 1, 2 и т.д 
// В скобках мы просто указываем какие значения будут у данного enum

const membership = Membership.Standard // 1
const membershipReverse = Membership[2] // Premium // Это называется реверс енум 

// Так же мы можем задавать enums более внятные значения 

enum SocialMedia {
    VK = 'VK',
    FACEBOOK = 'FACEBOOK',
    INSTAGRAM = 'INSTAGRAM'
}
// Если в данном случае мы будем обращаться к какому-то элементу данного enums, то мы будем получать строку
// Если мы явно указываем какую-то строчку, то вместо базовых чисел мы будем получать какое-то внятное значение 

// Перегрузка фунций
function add(a: number, b: number): number { // a,b - аргументы и какого типа они должны быть. А number после add это какого типа значение будет возвращать функция
    return a + b
}
// Идея в том что входящиие параметры мы также указываем через двоеточие : 
function toUpperCase(str: string): string {
    return str.trim().toUpperCase()
}
// TypeScript знает что тип string , то методы которые будут доступны для String
// Если элемент типа string , то и методы доступные для элемента будут для типа string

// В typesctipt также присутствует функционал который позволяет перегружать определенные параметры, перегружать футкцию
// Т.е вызывать функцию с разными параметрами и получать разные значения 

interface MyPosition {
    x: number | undefined
    y: number | undefined
}
// В некоторых языках программирования перегрузка функций или метод перегрузки  —  это возможность создавать несколько одноименных функций с разными реализациями.
// При вызовах перегруженной функции будет выполняться конкретная реализация этой функции в соответствии с контекстом вызова, позволяя одному вызову функции выполнять разные задачи в зависимости от контекста.

interface MyPositionWithDefault extends MyPosition{
    default: string
}
function position(): MyPosition
function position(a: number): MyPositionWithDefault
function position(a: number, b: number): MyPosition

function position(a?: number, b?: number) {
    if (!a && !b) {
        return {a: undefined, y: undefined }
    }
    if (a && !b) {
        return {x: a, y: undefined, default: a.toString()}
    }
    return {x: a, y: b} 
}
console.log('Empty: ', position())
console.log('One param: ', position(42))
console.log('Two param: ', position(10, 15))

// Классы в TypeScript 

class TypeScript {
    version: string // Указываем поля которые будут в этом классе. Например версию (verison)

    constructor(version: string) { // Конструктор который будет принимать в себя версию типа string 
        this.version = version // Можем сразу ее записать в приватную переменную version
    }

    info(name: string) { // Метод который будет возвращать
        return `[${name}]: TypeScript version is ${this.version}`
    }
}
// Модификатор readonly - который позволяет на этапе конпиляции определить что данные переменные никак не будут перезаписаны
class Car {
    readonly model: string // Поле model типа string 
    readonly numberOfWheels: number = 4 // По умолчанию будет равнятся 4 
    // Хорошей практикой считается если мы определяем поля до конструктора 
    constructor(theModel: string) {
        this.model = theModel
    }
}
// Учитывая что поле model у нас readonly мы все равно можем перезаписать, но можем это сделать только внутри конструктора 
// В других методах мы этого сделать не можем 

// Более лаконичная запись примера
class Car1 {
    readonly numberOfWheels: number = 4
    constructor(readonly model: string) {}
}

// Модификаторы полей в TypeScript

class Animal {
    protected voice: string = ''
    public color: string = 'black'
 
    private go() {
        console.log('GO!')
    }
}
// Бывает 3 вида модификатора public, protected и private
// Если к свойствам и функциям классов не применяется модификатор, то такие свойства и функции расцениваются как будто они определены с модификатором public.
// private - Если же к свойствам и методам применяется модификатор private, то к ним нельзя будет обратиться извне при создании объекта данного класса.
// protected - Модификатор protected определяет поля и методы, которые из вне класса видны только в классах-наследниках
// Если мы не пишем никакой модификатор, то по умолчанию все будут с модификатором public

class Cat extends Animal { // Класс Cat который наследуется от класса Animal
    public setVoice(voice: string): void {
        this.voice = voice
    }
}

const cat = new Cat()
// Когда мы задаем модификатор protected для обределенных свойств, то это означает что данные поля могут быть доступны в классе Animal и для всех классов которые наследуются от класса Animal
// Учитывая что это protected мы все равно в классе cat имеет до него доступ
// Когда мы создаем переменную Cat, то уже у инстанса класса мы не можем получить достпу до voice т.к он protected
// Privte переменные или методы они доступны только в том классе в котором были определены 
// Так же есть public переменные или методы которые доступны у всех инстансов

//--Абстрактные классы--//

// Не во что не компилируются, так же нужны на этапе разработки чтобы от них наследоваться 
abstract class Component {
    abstract render(): void
    abstract info(): string
}
// Тут мы описываем какие-то методы котороые должны быть реализованы у классов которые будут наследоваться от этого компонента и они также будут являтся обстрактными

class AppComponent extends Component {
    render(): void {
        console.log('Component on render')
    }
    info(): string {
        return 'This is info!';
    }
}

// Guards 

// Это некоторые вспомогательные конструкции в TypeScript которые позволяют нам так же с типами 
function strip(x: string | number) {
    if (typeof x === 'number') {
        return x.toFixed(2)
    }
    return x.trim() // удаляет пробельные символы с начала и конца строки
}
// В зависимости от разных типов переменной, нам нужно делать разный функционал
// Для этого мы используем оператор Typeof()
// instanceOf() - с помощью него мы можем проверить принадлежность какого либо объекта к классу

class MyResponse {
    header = 'response header'
    result = 'respons result'
}
class MyError {
    header = 'error header'
    message = 'error message'
}
// Мы создаем функцию которая обрабатывает и response и ошибку
function handle(res: MyResponse | MyError) {
    if (res instanceof MyResponse) {
        return { // return с фигурными скобками - возвращает объект 
            info: res.header + res.result
        }
    } else {
        return {
            info: res.header + res.message
        }
    }
}
// В качестве аргумента мы передаем некий объект res и он может быть типа класса либо MyResponse либо MyError

// Мы создадим свой собственный тип который назовем AlertType. Тип который будет принимаит в себя 2 значения

type AlertType = 'success' | 'danger' | 'warning'

function setAlertType(type: AlertType) { // Функция которая будет принимать в себя параметр тип alerttype
  //................... - что-то делает
}
// Передаем параметры которые есть у нас в типе alertType
setAlertType('success')
setAlertType('danger')
// Передаем параметры которых нет у нас в типе alertType
// setAlertType('default') - ошибка


// Типы Generic
const arrayOfNumbers: Array<number> = [1, 1, 2, 3, 5]
// Мы создаем переменную arrayOfNumbers. Мы можем указать тип используя Generic синтаксис 
// Мы обращаемся к классу Array который позволяет нам создавать массивы и указываем в треугольных скобках из чего данный массив будет состоять. Из чисел
// Указвыем объект и из чего он состоит

// Бывает такое когда одна функция может работать с разными типами данных 
function reverse<T>(array: T[]): T[] {
    return array.reverse()
}
// Функция reverse которая просто берет и поворачивает массив
// Функция будет принимать в себя массив и будет просто возвращать массив array и его встроенную функцию reverse
// Но массивы у нас бывают разных типов
// И как нам сделать так чтобы одна функция с указанием типов работала с разными типами данных 

// Мы можем указать что данная функция она работает с типом <T>
// Далее мы принимаем массив который является массивом типа T[]
// И возвращать мы также будем массив типа T[]
// И данный параметр будет динамически подстариваться под те значения которые мы передаем 
const arrayOfStrings: Array<string> = ['Hello', 'Vladilen']

// Теперь мы можем вызывать функцию reverse() c разными типами данных
reverse(arrayOfNumbers)
reverse(arrayOfStrings)
// Мы указали некоторый Generic тип <T>, который будет подстраиваться под определенный контент который есть в этом массив


// Вспомогательные операторы 
// Помогают нам взаимодействовать с типами 

interface Person {
    name: string
    age: number
}
// Теперь используя данный интерфейс мы можем создать отдельный тип который будет состоять из ключей данного интерфейса
type PersonKeys = keyof Person
// Мы создаем тип PersonKeys, и далее мы можем применить оператор keyof к интерфейсу Person
// И теперь на выходе в типе PersonKeys у нас могут находится следующие значения: 'name' | 'age'
let key: PersonKeys = 'name' // Мы спокойно можем присвоить переменной name
key = 'age'

// key = 'job' // Но при этом мы не можем занисти значение отличное от созданных
// Т.к key может принимать в себя только следующие значения: 'name' | 'age'

type User = {
    _id: number
    name: string
    email: string
    createdAt: Date // Тип DATE
}
// Мы создадим тип где мы будем указывать некоторые meta данные и обычные данные 

// Предположим что мы хотим воспользоваться данным типом и при этом создать новый тип, но не включающий в себя некоторые поля
// Мы можем сделать 2 способами 
type KeyUserNoMeta = Exclude<keyof User, '_id' | 'createdAt'> // Данном типе присутствуют только поле 'name' , 'email'
// Первый способ это применение специального ключевого слова Exclude, и далее в треугольных скобках мы описываем, что именно нам нужно сделать
// В первую очередь мы пробегаемся оператором keyof по типу User
// И дальше через запятую, объясняем что нам нужно исключить '_id' и 'createdAt'

// И теперь в данном типе у нас также присутствуют только поля 'name' , 'email'
// Существует также альтернативная запись 
type KeyUserNoMeta2 = Pick<User, 'name' | 'email'> // 'name' , 'email'
// В треугольных скобках мы указываем с каким типом мы работаем 
// Дальше через запятую указываем поля которые нам нужно забрать
// И теперь мы можем создавать различные переменные которые будут принимать в себя 
let ul1: KeyUserNoMeta = 'name'
// ul1 = '_id' - выдает ошибку, т.к может принимать значения 'name' , 'email'
// Ровно таже самая история с 2 типом 