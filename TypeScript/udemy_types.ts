/*
Type Annotations (Аннотации типов) и Type Inference (Вывод типов): 

Type Annotations (Аннотации типов) - код который мы добавляем в TypeScript, чтобы он понял,
значение какого типа будут содержаться в переменной 

Type Inference (Вывод типов) - TypeScript пытается сам определить, значения какого типа 
будут содержаться в переменной

Type Annotations (Аннотации типов): Мы как разработчики указываем тип для TypeScript
Type Inference (Вывод типов): TypeScript сам угадывает тип


Анотации для переменных: 

const oranges: number = 5;
const speed: string = 'fast'
cosnt hasDog: boolean = true

const nothing: null = null
const nothingOne: undefined = undefined

:number - это как раз анатация типов. Анотация типа number
Эта аннотация говорит что переменной oranges мы будем присваивать значения только типа число (number)
Если мы попытаемся присвоить любой другой тип данных, то получим ошибку в IDE
Тоже самое произошло даже при использовании ключевого слова let

Для встроенных объектов:
const now: Date = new Date()


Аннотации типов для объектных литералов: 
const array: string[] | number[]  = ['1', '2', '3']

Сама аннотация не создает массив. Она просто говорит что мы будем присваивать переменной array
что-то что является массивом из строк

Аннотации типов для классов:
class Car {

} 
let car: Car = new Car()

В данном случае мы говорим, что в переменной car будут содержатся объекты типа класса Car

Объектные литералы: 
const point: {x: number; y: number} = {
    x: 10,
    y: 20
}

Мы должны поместить двоеточие после названия переменной
А дальше хотим указать какой тип мы хотим присваивать этой переменной указываем фигурные скобки {}
Чтобы указывать свойства этого объекта и их типы

У этого объекта есть свойство x: number - с типом число. Далее нужно разделять из точкой с запятой
Мы должны разделять анотацию типов свойств объекта литерала точкой с запятой ;
Тем самым мы говорим что мы можем содержать свойства только числового типа

Если мы хотим изменить ключ например на a, то будет ошибка т.к в аннотации указана переменная x


Аннотации для функций: 
const logNumber: (i: number) => void = (i: number) => {
    console.log(i)
}

После двоеточия logNmber: идет аннотация 

Для функции, для нас как разработчиков важны 2 вещи: 1. Параметры которые принимает функция. 2. Возвращаемое значение
Здесь мы должны написать какие различные параметры будет принимать функция
И какие различне значения она будет возвращать

Прежде всего нужно указать в круглых скобках какие параметры будет принимать данная функция
После этого нам нужно указать, какие значения будет возвращать эта функция мы должны указать после стрелки
В данном случае наша функция не возвращает ничего void (тип значит пустой)


Что такое вывод типов?
- Когда мы наводим курсор на переменную TypeScript все равно понимает какой тип значения мы будем присваевать этой переменной
Даже без анатаций типов. Это система вывода в действии

Если объявление и инициализация переменной происходят в одной строке TS может понять тип значения 'color'

      1         2
const color = 'red'

1. Объявление переменной (декларация)
2. Инициализация

Т.е все анатации типом можно не использовать т.к TS догадывается какой тип у переменной должен быть
Если мы делаем декларацию и инициализацию в одной строке TS догадывается какие значения мы будем хранить в этой переменной
И делает так называемый вывод типов. TS делает вывод что в переменной oranges будут хранится значения только числового типа

Когда нам добавлять типовые анотации?

Type Annotations (Аннотации типов)
- Когда переменная объявляется, а инициализируется позже
- Когда создается переменная, вывод о типе которой не может быть сделан
- Когда функция возвращает тип 'any' и нам нужно уточнить тип

Type Inference (Вывод типов)
- Всегда 

Тип 'Any'

Когда использовать аннотации типов: 
    - Когда функция возвращает тип 'any' и нам нужно уточнить тип

const json = '{"x": 10, "y": 20}'
const coordinates: {x: number; y: number} = JSON.parse(json)

Метод JSON.parse() возвращает тип 'any'

Как работает метод JSON.parse()?
    - При передачи значения в метод у них остается тип который их принадлежит
Но TypeScript определяет их как тип 'any'

Каждый раз как мы передаем строку в метод parse(), то мы получаем разные значения
И проблема в том что TypeScript не может предсказать все эти разные значения. 
Не можем предсказать, что же мы все таки получим из этого метода

Потому-что это зависит полностью от того какую строку мы передаем в этот метод

Тип 'any':
    - Такой же тип, как например 'string' или 'number'
    - Это значит, что TS понятия не имеет что это и не может проверить на содержание ошибок 
    - Избегайте переменных с типом 'any' любой ценой

TypeScript - зная все типы может проверять, правельно ли мы используем вызов свойств или функций для этой переменной
Потому-что он знает какие значения какого типа содержатся в переменной и может нам указать на ошибку или опечатку
И когда мы получаем тип any TypeScript не может ничего исправить и подсказать


Исправление типа 'any':
    - Один из способов это добавить анотацию типов переменной
Так мы в переменной парсим из JSON в объект, то аннотацию типов нужно использовать как для объекта

const coordinates: {x: number; y: number} = JSON.parse(json)

Все что нужно сделать, это каждый раз когда возвращается тип any добавлять аннотацию типов


Отложенная инициализация: 
    - Когда переменная объявляется, а инициализируется позже

let words = ['one', 'two', 'tree']
let isTwo: boolean;

for (let i = 0; i < words.lenght; i++) {
    if (words[i] === 'two') {
        isTwo = true
    }
}

Каждый раз когда мы делаем объявление и присваивание значение в разных местах кода нам нужно вручную добавлять аннотацию типов

Когда создается переменная, вывод о типе которой не может быть сделан:
    
let myNumbers = [-10, -1, 12]
let positiveNumber: boolean | number = false
for (let i = 0; i < myNumbers.length; i++) {
    if (myNumbers > 0) {
        positiveNumber = myNumbers[i]
    }
}


Аннотации типов для функций:

    - Type Annotation (Аннотации типов) для функций:
Код который мы добавляем для TypeScript, чтобы он понял, аргументы какого типа будет принимать функция
и значение какого типа она будет возвращать

    - Type Inference (Вывод типов) для функций:
TypeScrip пытается сам определить, значение какого типа будет возвращать функця


Аннотации типов для функций:

const add = (a: number, b: number): number => {
    return a + b
}

Выводы типов для функций:
    - TypeScript следит только за типами, за логикой он не следит

- При передачи аргументов нам всегда нужно использовать аннотацию типов. Для аргументов нет вывода типов
- Для возвращаемого значения есть вывод типов, но мы его не будем использовать. У нас есть вывод типа только для возвращаемого значения

Единственная возможность увидеть сообщение об ошибке, это явно указать тип возвращаемого значения
Т.к если тип будет any, или void TypeScript не сможет сообщить нам об ошибке


Void & Never

const logger = (message: string): void => {
    console.log(message)
}

Тип void - означает пустой. Означает что функция не возвращает ничего
Такие функции могут возвращать значение null, также undefined

const throwError = (message: string): never => {
    thow new Error(message)
}

Тип never - означает никогда. Означает что мы никогда не будем достигать конца этой функции
Каждый раз где-то в функции мы будем выбрасывать ошибку. 
Используется только в том случае когда мы полностью уверены, что мы не будем достигать конца функции
И небудем возвращать никакое значение из этой функцции


Деструктуризация 

const todayWeather = {
    date: new Date(),
    weather: 'sunny'
}

const logWeather = (forecast: {data: Date; weather: string}): void => {
    console.log(forecast.date)
    console.log(forecast.weather)
}
logWeather(todayWeather)

Для деструктуризации переменный Date и weather от объекта forecast

const logWeather = ({date, weather}: {data: Date; weather: string}): void => {
    console.log(date)
    console.log(weather)
}
logWeather(todayWeather)

Каждый раз когда мы хотим использовать деструктуризацию мы должны ее заменить на деструктуризационный стейтмент
Мы не используем аанотацию типов вместе с деструктуризацией
Сначало нам нужно сделать деструктуризацию, а затем сделать аннотацию свойств


Аннотации для объектов

const profile = {
    name: 'Jack',
    age: 25,
    coordinates: {
        lat: 1,
        lgn: 20
    },
    setAge(age: number): void {
        this.age = age
    }
}
cosnt { age }: { age: number } = profile

Если мы используем деструктуризацию, ее аннатацию мы должны писать в виде структруры объекта

Получение вложенного объекта:

const { coordinates: { lat, lgn } } : { coordinates: { lat: number; lng: number }} = profile

Свойство coordinates является объектом поэтому внутри мы указываем еще одни фигурные скобки обращаемся к свойствам объекта и указываем аннотации


Массивы в TypeScript 

Typed Array (Типизированные массивы) - массивы в которых каждый элемент - это значение определенного типа

Если мы создаем массив для строк, то массив будет содержать только строки

const colors: string[] = [ 'red', 'green', 'yellow']

Подобная запись с явным приведением типа будет использоваться когда мы инициализируем пустой массив

const dates = [new Date(), new Date()]

cosnt fruitsByColor = [
    ['tomato'],
    ['apple'],
    ['lemon']
]

string [][] - означает двух мерный строковый массив
Это значит что у нас есть массив который содержит массив из строк
В данном примере аннатация типов не нужна, т.к TS поймет тип этого массива

const fruitsByColor: string[][] = [

]

Для чего нужны массивы в TS?

    - TS может сделать вывод типа, когда извлекает значения из массива
    - TS может предотвратить добавление несовместимых типов в массив
    - Мы можем получить помощь использую функции 'map', 'forEach', 'reduce'
    - Гибкость - массивы все же могут содержать значения разных типов  


TS может сделать вывод типа, когда извлекает значения из массива:

const color = colors[0] // тип string
const color = colors.pop()


TS может предотвратить добавление несовместимых типов в массив

colors.push(true) - ошибка!
Мы пытаемся добавить в массив boolean значение в коллекцию в которой только строки


Мы можем получить помощь использую функции 'map', 'forEach', 'reduce'

colors.map((color: string): string => {
    return color.toUpperCase()
})
Используя методы TS будет автоматически выдавать список методов и свойств для переменной 


Массивы со значениями разных типов:

const importantDate: (Date | string)[] = [new Date(), '2022']

В данном случаем автоматически выводит что этот тип массив, и этот массив будет содержать значения типа строка и дата
Если мы при инициализации используем только один тип, но потом хотим использовать два типа, 
тогда мы должны явно показать это TS. Мы должны указать это в аннотации

Когда используются типизированные массивы:
    - каждый раз когда нам нужно представить коллекцию записей в случайном порядке


Tuples (Кортежи)
    - это структуры похожие на массивы, в которых каждый элемент - это какое-то свойство записи
Описывают одну запись, но несколько свойств этой записи. Внутри Typle мы часто содержим значения разных типов
Т.к как у одной записи может быть много разных свойств. Эти свойства могут отображаться с помощью различных типов значений

Пример:

    Объект отображающий напиток
    
    const drink = {
        color: brown
        corbonated: true
        sugar: 50
    }

    [brown, true, 50]

Typle - так и выглядят. Когда мы помещаем значения в массив в строгом порядке

    const drink = {
        color: brown
        corbonated: true
        sugar: 50
    }


type Drink = [string, boolean, number]
const cola: Drink = [brown, true, 50]

Проблема в том, что мы можем перепутать порядок свойств
Эта аннотация превращает этот массив в Typles
Теперь в этом массиве, все элементы будут в определенном порядке

type Drink = [string, boolean, number] - это так называемый типовой элисас
Мы сможем использовать этот тип в любом месте программы

Тепрь мы можем создавать новые Typles с использованием элиаса

Если мы используем какие-то значения которые обозначают какую-то характеристику
В Typles нам сложно понять с чем мы работаем если нет доп комментариев


Interface
    - создает новый тип, описывая названия свойств и типы значений объекта

Интерфейс необходим для сокращения аннотации типов для объектов, т.к каждый раз не нужно прописывать аннотации
Каждый раз когда мы создаем интерфейс мы создаем новый тип. Пишем интерфейс с заглавной буквы
При названии мы должны использовать общий термин. И в нем пишем какие свойства будут иметь объекты с типизацией

interface Vehicle {
    name: string;
    year: number;
    broken: true;
    summare(): string;
}
И каждый объект который мы создадим должнен иметь такие свойства и типы свойств

Синтаксис интерфейсов:
    - Когда мы объявляем интерфейс, мы должны перечислить свойства и также типы этих свойств. 
Для кокого-то объекта который будет новым объектом
Внутри интерфейсов мы можем указывать любые типы значений

summary():

- Мы добавляем в интерфейс функцию в которой мы должны указать тип значения которое должна возвращать эта функция
Т.е мы говорим что новый объект который имеет тип Vehicle должен иметь функцию summary() с возвращаемым значением типа строка

Функции в интерфейсах
    - Если задачи для интерфейса изменились, то нужно его переназвать

Если объекты имеют свойства совподающие с интерфейсом, они могут предендовать на присвоение одного типа интерфейса

Основная стратегия повторно используемого кода в TS:
    - Создание функций, которые принимают параметры, типизированные при помощи интерфейсов
    - Объекты / Классы могут "имплементировать" нужный интерфейс для работы функций 


Создание функциональности с помощью классов

    - Классы
Это шаблон для создания объектов - с полями (значения) и методами функций для отображения "Чего-то" в приложении

class Vehicle {
    drive(): void {
        console.log()
    }
}

const vehicle = new Vehicle()
vehicle.drive()

Также как и interface, класс пишется с большой буквы
Когда мы создаем класс, мы как бы создаем шаблон того как будет себя вести какой-то объект

Часто мы будем использовать класс для создания объекта класса (instance - сущность)


Основы наследования
    
class Car extends Vehicle {

}

Когда мы наследуемся от какого-то класса. Мы можем опционально по нашему желанию, переопределять методы класса родителя
Чтобы этот метод вел себя в классе наследнике подругому. Для этого нам нужно переопределить методы в классе наследнике

Модификаторы методов объекта
    - public - этот метод может быть вызван откуда угодно, в любое время
    - private - этот метод может быть вызыван только другими методами внутри того же класса
    - protected - этот метод может быть вызыван другими методами внутри того же класса или другими методами внутри класса наследника

Это ключевые слова которые мы можем помещать для методов и свойств классов
Цель модификаторов ограничивать доступ для различных методов и свойств

По умолчанию все методы и свойства класса имеют модификатор public

class Vehicle {
    public drive(): void {
        console.log()
    }
}

class Car extends Vehicle {
    private drive(): void { !ошибка
        console.log()
    }
    startDrivingProcess(): void {
        this.drive()
    }
}

В том что мы не можем вызывать этот метод снаружи класса Car, мы можем это делать только внутри этого класса 
Теперь внутри метода startDrivingProcess() мы можем вызывать приватную переменную drive, т.к сейчас мы находимся внутри класса Car

Модификатор private - ограничивает доступ к методам которые могут вызвать другие разработчики.
Чтобы не давать им возможность вызывать этот метод

Модификатор protected (защищенный) - в нем все те же самые свойства как у private, только еще добавляется доступ изнутри класса наследника
Не только внутри самого класса, но и внутри класса наследника 

Модификаторы позволяют типизировать работу с свойствами и методами класса/объекта добавляя тип доступа 


Поля в классаъ: 
    - 

Функция constructor() {} - это специальная функция определяемая внутри класса
Запускается автоматически как только мы создаем новый объект класса
И в этот конструктор можем передавать параметры как в обычную функцию

constructor(public color: string) {
    this.color = color
}
const vehicle = new Vehicle('black')

Чтобы сократить данную запись можно использовать модификатор доступа public
Вызовы классов наследников должны содержать ключевое слово super

Где используются классы?
    Interface + Class - повторное использование кода в TypeScript


Generic types
    - по соглащению generic обозначают одной заглавной буквой <T>

class ArrayOfNumbers {
    constructor(public collection: number[]) {}

    get(index: number): number {
        return this.collection[index]
    }
}

class ArrayOfString {
    constructor(public collection: string[]) {}

    get(index: number): string {
        return this.collection[index]
    }
}

class ArrayOfAnithing<T> {
    constructor(public collection: T[]) {}

    get(index: number): T {
        return this.collection[index]
    }
}

<T> - это как параметр и каждый раз при создании объектов класса
































































































*/ 

