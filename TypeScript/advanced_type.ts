/*
План на изучение:
1. Настройка TypeScript,
2. Про компилятор
3. Настройка проекта
4. Фичи для использования
5. Generic type
6. Декораторы 
7. Модули
8. Namespace
9. Дополнительные библиотеки которые можно использовать в TypeScript
*/

/*
Инициализация проекта: 
1. Ввести команду в терминале npm init. 
- Чтобы оставить все настройки по умолчанию (без изменений): npm init -y
2. Далее устанавливаем зависимость для работы с TypeScript: npm i -D typescript
- Чтобы пользоваться возможностями TypeScript нужно установить глобально
- Для проверки правельности: tsc -v
- Если локальная версия TS и глобальная версия TS различаются нужно их синхронизировать: npm i -g typescript

Компилятор TypeScript. Что это такое и как это работает?
1. Создаем файл с расширением .ts и создаем константу для теста с типом: const message: string = 'Hello from TypeScript'
2. Чтобы скомпилировать файл нужно в терминале ввести название файла: tsc data.ts 
3. Файл скомпилируется в корень приложения в ES5 синтаксис т.к присутствует ключевое слово var

- Набираем команду: tsc --init: в консоле получаем сообщение что был успешно создан файл tsconfig.json
tsconfig.json - внутри файла мы увидим большое кол-во опций и настроек в TypeScript

Настройка TypeScript:
- Файл в формате JSON: tsconfig.json 

В этих настройках мы можем настраивать сам компилятор
Также есть вторая настройка exclude: [] - которая содержит в себе ссылки на файлы которые компилировать не нужно. Игнорировать
По умолчанию там лежит папка node_modules, но она не прописана на прямую

Также есть настройка include: [] - которая содержит в себе ссылки на файл которые наоборот нужно компилировать
Также "files": [] - какие файлы напрямую нужно компилировать

Т.к мы пишем config в формате json, то ковычки должны быть двойные 

Настройки "compalerOptions": []

"outDir": "./dist" - говорит что все скомпилированные файлы нужно будет складывать в папку dist
"rootDir": "./src" - корневая директория находитсмя в папке src

Чтобы не писать каждый раз tsc нужно написать tsc -w, tsc --watch чтобы TS следил за изменениями TS файлов

"target": "es5" - определяет в какой формат языка будет компилироваться файл ts. Влияет только для каких браузеров будет написан код
Если мы нажмем сочетание клавиш Control + пробел мы увидим все возможные опции которые мы можем указывать

"module": "commonjs" - определяет в каком формате будут проихзводтится import и export

"lib": [] - по умолчанию это пустой массив. Данная настройка регулирует какие библиотеку нужно включить в понимание TS
Мы как-бы надстраеваем TS еще и браузерным API
На сайте TS мы можем увидеть какие модули и библиотеки мы можем подключить к нашему TS.
Некоторые методы которые есть в JS просто будут подсвечиваться из за отсутвия в TS. Это нужно добавить в lib

По умолчанию в TS мы не зашиваем браузерный API

"removeComments": true - удаляет все комментарии в финальной сборке

"strict": true - означает что все настройки которые идут ниже, находятся в значении true


Дополнительные проверки
    - предназначены по сути проверки стиля написания кода

"noUnusedLocals": true - если в функции например есть какие-то неиспользуемые локальные переменные, то по умолчанию видно
    данная переменная не используется TS выдает как ошибку. Что-то вроде eslint для TS. 
    Это не касается неиспользуемых глобальных переменных. Потому что потенциально такая переменная может исопльзоваться в других файлах



Generic Types
    - 

<> - мы указываем скобки и говорим из чего состоит данный массив 

const cars: stirng[] = ['Ford', 'Audi']
const cars: Array<string> = ['Ford', 'Audi']

<T> - обычно все generic начинаются с буквы T что означает Type
Данная функция работает с некоторым волшебным типом T
<T, R> - эти типы являются generic и подстраиваются под входящие данные 

function mergeObject<T, R>(a: T, b: R): T & R {
    return Object.assign({}, a, b )
}

Использую generic types мы явно не привязываемся к какому-то объекту и при этом делаем нашу фукнцию более универсальной

function mergeObject<T extend object, R extend object keyof>(a: T, b: R): T & R {
    return Object.assign({}, a, b )
}

Также помимо наследования от объекта можно наследоваться и от интерфеса

Оператор keyof - берет и получает все необходимые ключи у входящего объекта
Используется при использовании generic types у объектов



*/

