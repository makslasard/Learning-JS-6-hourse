// use strict - строгий режим. Все сценарии работают в современном режиме.

//--------------------Простое общение с пользователем-------------------//

const result = confirm('Пользователь, ты еще сдесь?'); // confirm появляется в модальном окне, с двумя кнопками 'OK' или 'Отмена'. 
// Дает возможность пользователю совершить выбор 'ДА' или 'НЕТ'
// Результат выбора пользователя помещаеться в переменную в формате boolean. result = true / false;

const answer = prompt('Вам есть 18?', '18');
// Первое значение это вопрос который мы спрашиваем у пользователя. 
// Второе значение это дефолтный ответ от пользователя. Если нет стандартного ответа ковычки пишутся всегда пустые
// Результат ответа пользователя будет помещен в переменную. 
// В любом случае чтобы не ответил пользователя значением будет тип данных строка

// ВАЖНО!!! Вся информация которая приходит от пользователя всегда приходит в виде строк. В независимости как вы ее получили. 
// Если к prompt поставить + (+prompt) - то число будет типа number. Это так называемая динамическая типизация
// В данном случае мы строку преобразовали в число

const answers = [];
// answers[0] = 'Первый элемент массива!'; // С помощью квадратных скобок можно не только получить значение , но и записать его
answers[0] = prompt('Ваше имя?', ''); 
answers[1] = prompt('Ваша фамилия?', '');
answers[2] = prompt('Сколько вам лет?', '');

// Команды которые мы используем в этом уроке нужно тестировать только внутри браузера. Так как внутри терминала таких команд просто нет

//--------------Интерполяция-----------------//
// Это значит что мы прямо внутри строки можем вставлять значение переменной ${category}
// Прием интерполяции был придуман чтобы не склеивать большое колличество значений в одну строку. 
// Можно использовать только с обратными ковычками ``. 
const category = 'toys';
console.log(`https://someurl/${category}/5`);
// Значение переменной может нам прийти откуда угодно из базы данных, скрипта, и т.д

//------------Операторы JS---------------//
let incr = 10,
    decr = 10;

incr++; // Оператор инкримента т.е увеличение на 1
decr--; // Оператор дикремента т.е уменьшение на 1

++incr; // Когда оператор ставиться перед переменной называеться префиксным, когда после тогда постфиксный
--decr;
// Когда мы использует инкримент и дикремент в постфиксной форме прям сразу, то код исполняеться с лева на право. 
// Поэтому сначало получаеться старое значение которое выводится в консоль, а потом начинаеться сложение 
// Чтобы сразу использовать икримент нужно использовать префиксную форму

// Знак процента в JS возвращает остаток от деления 5 % 2 = 1;

// && - 'И' : работает только тогда когда 2 и больше подоных является true
// || - или : работает когда один из вариантов будет true

//------------Условия---------------// Урок.13
// Добавленная информация содержится в основном обучающем JS файле

// Конструкций switch case
const num1 = 50;

switch (num1) { // В условие мы помещаем объект того что мы будем сравнивать, что проверять
    case 49: // Прописываем дерективу case и указываем, то значение которое мы хотим проверить 
        console.log('Неверно');
        break;// После каждого условие нужно прописывать ключевое слово break. Это обязательная синтаксическая конструкция. 
    case 100:
        console.log('Неверно');
        break;// Если мы пишем слово break на этом все закончится 
    case 50:
        console.log('В точку');
        break;
    default: // Если не одно из условий не выполниться , то сработает default действие по умолчанию 
        console.log('Не в этот раз!');
        break;
}
// Конструкция switch всегда идет на строгое сравнение в отличие от обычных условий. Проверяем только на строгое соответствие 

//---------------Цикл-----------------//

// Используется для повторения однотипных действий

/*const num = 50;
while (num < 55) {
    console.log('num');
    num++;
};*/

/*do { // Сначало выполняется какое-то действие, а потом проверяется условие
    console.log('num');
    num++;  
}
while (num < 55)*/

// Самый часто использующийся

for (let i = 1; i <= 8; i++) {
    if (i === 6) {
        break; // Ключевое слово полностью завершает работу цикла
        // continue - оператор позволяет пропустить шаг который нам не нужен
    }
}
// Условие цикла состоит из 3х параметров: 1. С чего начнется цикл. 2.Условие при котором наш цикл остановит свою работу
// 3. Мы записываем шаг цикла
// Именно цикл позволяет работать с большим количеством элементов 20,30,40 и тд

// Функции
let num2 = 20;

function one(text) { // Мы можем передать параметры которые функция может использовать внутри себя
    console.log(text, arg, num)
    let num = 10 // Не отображается т.к итератор ее не видит
}
one('Hello world!'); // Параметр будет подстовлятся вместо text
console.log(num); // 20  - т.к num через значение у глобальной переменной , про переменную внутри функции интерпритатор не знает
// Аргументов может быть бесконечное количество
// Переменная которая создана глобально может использоваться внутри других функций

// Замыкание

// Это сама функция вместе со всеми внешними переменными которые ей доступны

// Когда у нас внутри какой-то функции есть обращение к какой либо переменной
function one(text) { 
    console.log(text, arg, num)
    console.log(num); 
}
// Если переменная num не находит для себя значение внутри функции , то она поднимается для поиска на уровень выше 
// Где и находит глобальную переменную. Идет до конца до самого высшего уровня

function ret() {
    let onn = 60;

    // Выполнение большего кол-во кода

    return onn;
}

const onnON = ret();
// Виды функции

// Function Declaration 
function foo() {

}
// Создается до начала выполнения скрипта, можно вызвать перед объявлением

// Function Expression
let foo = function() {

}
// Создается только тогда , когда доходит поток кода, можно вызвать только после объявления

// Стрелочные функци
//() =>
// Не имеют своего контекста
const calc = ( a,b ) => {
    console.log('1')
    return a + b
}
// Методы и свойства строк и чисел

const str2 = 'Hello!'
const arr1 = [1, 2, 3] 
console.log(arr.length) // length - это единственное свойство
// Все методы пишутся с круглыми скобками т.к они выполняют какое-то действие над строкой метод() 

// indexOf - ищет элементы в строке . Если результат -1 , то такой кусочек строки не был найден
// slice - Вырезает от одного элемента до другого . Задаем 2 значения: 1. С какой части строки нужно что-то возвращать. 2. До какого элемента вырезать
// Не включая последний элемент (1, 7) - вырежет с 1 по 6
// Метод поддерживает и отрицательные значения, и начинается с конца

// Метод substring похож на slice. Принимает в себя start и end
// Метод substr отличается что 2 аргумент принимает в себя количество символов которые нужно вырезать substr(1, 5);

// Методы работы с числами
// Math - math.round() округляет число до ближайшего целого
// parseInt - переводит число в другую систему исчисления. Может обрезать число и превратить в числовой тип данных
// parseFloat - взять число или строку и вернуть в десятичном варианте. Возвращает значение с плавающей точкой

// callback - функции

function start ( ) {
    // Выполняеться какой-то код. Загрузка данных с сервера, или обработка файлов
    setTimeout(function() {
        console.log('Загрузка с задержкой в 0.5 секунды!')
    }, 500) // Для примера работы задержки
}
// Функция в себе имеет задержку
// Из за задержки функция при выполнении будет не видна , т.к сначало выполнется функция без задержки

function second() {
    console.log(2)
}

start();
second();
// Если функции в коде идут одна за другой, это не значит что они дадут результат в одно время

// callback - это функция которая должна быть выполнена после того как другая функция завершила свое выполнение 
function learnJS(lang, callback) {
    console.log(`Я учу: ${lang}!`)
    callback();
}

function todo() {
    console.log('Я прошел этот урок!')
}

learnJS('JavaScript', todo)
// Передаем аргумент callback - это главный шаблон callback функций
// Что в будующем через аргумент callback мы сможем передать другую функцию
// После выполнения первого действия выполниться строго вторая функция
// Всегда должна сохранятся последовательность функций

// Если в дальнейшем нам нужно будет использовать функцию callback 
// При вызове todo мы не ставим () - скобки т.к мы передаем функцию , а не вызываем. Чтобы в дальнейшем она была использована
// callback функции позволяют нам быть уверенным в том что определенный код не начнет исполнение до того момента пока другой код не завершит свое исполнение

// Объекты, деструктуризация объектов
const obj2 = new Object();  // Создаем новый объект. Зачастую никогда не используется 

const options = { // Объект заполняется в формате  ключ: значение 
    name: 'Ivan',
    width: 1024,
    heigth: 1024,
    color: {
        border: 'black',
        bg: 'red'
    }
};
// Оператор delete - удалить что-то
delete options.name;
// Для перебора методов в объекте используется цикл for in. Возвращает значение в формате ключ: значение
// Цикл for in будет отрабатывать столько раз, сколько методо у нас в объекте 
let counter = 0;
for ( let key in options) {
    if (typeof(options[key]) === 'object') { // 
        for (let i in options[key]) { // Перебор объекта внутри объекта
            console.log(`Свойство ${i} имеет значение ${options[key][i]}`); // i используется чтобы достучатся до методов внутри color
            counter++; 
        }
    } else {
        console.log(`Свойство ${key} имеет значение ${options[key]}`);
        counter++; 
    }
    
};
// При простом переборе итератор не сможет отобразить object color и выведет [object object]
// Чтобы этого избежать мы создадим итератор внутри итератора
// console.log(options['colors']['border']);

// Рекурсия - это когда функция вызывает сама себя
// У объекта нет свойства length , поэтому мы будем создавать счетчик для подсчета

//Object.keys() - берет наш объект и на его основании создает массив  в котором все элементы ключи находящиеся в объекте
// [ 'name', 'width', 'height', 'color' ] - у получаемого массива мы можем использовать свойство length
// console.log(Object.keys(options).length)

// Мы можем создават такие методы вручную
/* 
const options = { 
    name: 'Ivan',
    width: 1024,
    heigth: 1024,
    color: {
        border: 'black',
        bg: 'red'
    },
    makeTest: function() { // Мы создали свой метод который будет работать внутри options
        console.log('Hello!')
    }
};
*/
// Метод это действие которое умеет совершать наш объект
// Чтобы запустить метод: options.makeTest(). Если ставятся круглые скобки, значит что-то идет в работу
// Объекты это тип данных который может сохранять в себе любые типы данных в формате ключ: значение. Так же объекты могут быть вложены в объекты
// Чтобы перебрать объект нужно использовать for in
// Чтобы наш объект умел что-то делать мы можем создать функции ( методы )

// Так же ты можешь встретить в работы так называемые методы аксессоры - это get и set

// Деструктуризация объектов
// Мы будем вытаскивать переменные в качестве отдельных структур, которые мы будем выносить за наш объект и как-то уже в дальнейшем использовать

const { border, bg } = options.color; // Эта структура называется деструктуризацией
console.log(border);
// Внутрь фигурных скобок помещается те переменные которые нужно вытащить
// После присваивания мы пердаем структру из которой мы хотим вытащить эти объекты
// Т.е деструктурировать - разделить на более мелкие и удобные кусочки
// Используется для более удобной работы с большой вложенностью внутри объектов 

// ВАЖНО! Строка на базовом уровне , тоже является объектом и получает этот метод через цепочку прототипов 

//----Массивы и псевдомассивы---

// Это структуры которые содержат элементы по порядку

const arr2 = [1, 2, 3, 4, 5, 6];

// Перебор массива
for ( let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}

for (let value of arr) {
    console.log(value); // value - это каждый отдельный элемент
}
// Создаем переменную в которой будут хранится все элементы массива. Далее указываем в каком массиве мы будем работать
// Свойство length состоит из последнего элемента в массиве + 1
// ВАЖНО!!! Пример
/*
const arr = [1, 2, 3, 4, 5, 6];
arr[99] = 0; // добавляем 0 на 99 позицию в массив
console.log(arr.length); // 100 т.е 99 элементов в массиве + 1
console.log(arr); // [1, 2, 3, 4, 5, 6 <94 empty items>, 0]; - Мы получаем массив с пустыми ячейками
*/

//--------ForEach()-----------
// Метод forEach() выполняет указанную функцию один раз для каждого элемента в массиве
arr.forEach( function (item, i, arr) {
    console.log(`${i}: ${item} внутри массива ${arr}`); // 0: 1 внутри массива 1, 2, 3, 4, 5, 6;
})
// Принимает в себя callback функцию
// Может принимать в себя 3 аргумента
// 1. Это тот элемент который мы сейчас перебираем назовем item. Назвать можно как угодно
// 2. Это номер по порядку
// 3. Это ссылка ссылка на тот массив который мы перебираем arr
// callback функция нужно чтобы строго выполнится после определенных действий

//ВАЖНО!!! Когда использовать цикл , а когда for of?
// В for of мы можем использовать такие ключевые слова как break и continue. Очень важны если нам когда-то нужно будет остановить цикл либо полностью либо пропустить одно повторение
// Когда мы испльзуем forEach мы не сможем его остановить на каком-то этапе

// Методы перебора массивов
// .map - как и forEach перебирает элемент, но при этом его модифицировать. В конце вернет новый массив с модифицированными элементами
// .filter - отфильтровываем по тому критерию который мы туда задаем 
// Эти методы так же являются методами трансформации массивов, они берут исходный материал и его модифицируют. А метод forEach просто его перебирает

// split - превращает строку в массив. 
const str3 = prompt('', ''); // Получаем от сервера данные в виде строки с разделителем
const products = str.split(', '); // Внутри должны указать, через какой разделитель будут элементы в строке. За
// Команда prompt существует только внутри браузера
// Результат работы split() - 0: 'qqqq', 1: 'qqqq' и тд по кол-во элементов
// .join() - объединение элемента массива в строку. Должны указать через какой разделитель будут выводится элементы на страницу 
console.log(products.join('; ')); // Получаем строку через ; . wwww; ewweq; ewrwer
// .sort() - сортирует элементы внутри массива как строки
// Если массив из строк , отсотрирует по алфовиту
// Если масив из чисел, отсортирует как строки по первому символу числа  [10, 12, 2, 26, 28, 8]
// Метод .sort() - может принимать в себя callback функцию , как именно сортировать данный массив

const arr = [10, 12, 2, 26, 28, 8];
arr.sort(compereNum);

function compereNum(a, b) {
    return a - b
}
// Элементы отсортируются по порядку
// Метод имеет внутри себя алгоритм быстрой сортировки 

// Понятие псевдомассивов 

// Когда мы работаем с элементами на странице, то мы будем полуать псевдомассивы
// Это объект структура которого совподает с структурой массива. У таких массивов не будет никаких методов, это просто структура которая хранит данне по порядку

// Передача по ссылке или по значению

/*
Изменяя что-то внутри копий, мы модифицируем изначальный объект
Когда мы работаем с какими-то примитивными типами данных, то они передаются по значению
*/
let a = 5; // Такая констукция, работает только с примитивами
    b = a;

b = b + 5;
console.log(b);
console.log(a);

const obj = {
    a: 5,
    b: 1
}
const copy = obj; // В переменную copy кладется ссылка на уже существующий объект
copy.a = 10; // Когда мы модифицируем копию, мы как бы модифицируем наш изначальный объект
// Когда мы работаем с объектами (массивы, функции и т.д), то у нас идет передача не по значению, а по ссылке

// Создание копии объекты с помощью цикла
function copeOne (mainObj) {
    let copeObj = {};

    let key; // Переменную можно создавать и вне функции
    for ( key in mainObj ) {
        copeObj[key] = mainObj[key];
    }
    return copeObj; // Возвращаем результат, чтобы с ним можно было работать
}
// Берем copeObj, внутри создаем новое свойство через [] квадратные скобки. Это свойство которое будет содержать в себе такое же обозначение как и в  главном объекте
// Дальше мы делаем копию из нашего главного объекта 
// Мы пройдемся по нашему старому объекту , скопируем его свойства и запишем их в новую копию. Которая изначально была пустым объектом 

const number = {
    a: 2,
    b: 5,
    c: {
        x: 7,
        y: 4
    }
}

const newNumbers = copy(number) // Мы создали копию

newNumbers.a = 10;
newNumbers.c.x = 10;
// Когда мы вот так клонируем объекты есть 2 очень важных понятия это глубокие и поверхностные копии обхъектов 
// Сечас мы создали поверхностную копию, она берет все обычные свойства которые были в родителе и создает как-бы независимые структуры
// Как только у нас появляется вложеная структрура, то это свойство опять же будет иметь ссылочный тип данных 

// Создание копий с помощью object.assign()

// У нашего глабального типа данных object есть такой метод который позволяет вам соеденить сразу несколько объектов 
const add = {
    d: 17,
    e: 20
}
console.log(Object.assign(number, add))
// Первым аргументом мы передаем тот объект в который хотим все это поместить 
// Вторым аргкментом тот объект который помещаем 
// Мы создали независимую поверхностную копию объекта, она никак не зависит не от number и add

// Тоже самое мы можем сделать с пустым объектом чтобы просто создать копию объекта number мы заменяем на пустой объект
// console.log(Object.assign({}, add)) - у нас создается новый объект, в него помещаются какой-то старый объект и мы получаем отдельную копию
const clone = Object.assign({}, add)
clone.d = 20;

console.log(add) // { d: 17, e: 20 }
console.log(clone) // { d: 20, e: 20 } - клонированныей объект

// Методы для создания копии массива 
const oldArray = ['a', 'b', 'c'];
const newArray2 = oldArray; // В данном случае в newArray положиться ссылка на oldArray. Изменяя newArray будем изменять oldArray

const newArray = oldArray.slice(); // Метод который позволяет просто скопировать старый массив
// В него можно передать аргументы по количеству элементов.
newArray[1] = 'asdasdasd';
console.log(newArray); // Результтат ['a', 'asdasdasd', 'c']
console.log(oldArray); // Результтат ['a', 'b', 'c']

// Новые стандарты ES7 и ES8
// 4 способом создания поверхностных копий будет использование оператора разворота. ES6 появился для массивов, в ES7 для объектов 
// Оператор называется Spread - оператор разворота, имеет такое название т.к он разворачивает структуру и привращает ее в набор каких-то данных 
const video = ['youtube', 'vimeo', 'rutube'],
      blogs = ['wordpress', 'livejournal', 'blogger'],
      internet = [...video, ...blogs, 'vk', 'facebook'];
// Сделаем так чтобы в этой переменной склонировались все значения из переменной video, blogs, и еще добавились какие-то свои которые там будут
// Мы берем перменную video и spread оператор должен развернуть эту структуру на отдельны значения для этого мы ставим троеточие перед переменной ...video, так же делаем с blogs
// Оператора ... троеточие развернул массивы на отдельные элементы и совместил в новом массиве 

function log(a, b, c) { // Фунции log используются обычно для логирования каких-то данных
    console.log(a)
    console.log(b)
    console.log(c)
}
const num = [2, 5, 7]; // Предположим что массив сформировался на сервере, на стороннем ресурсе
// Например: 1. Ссылка на сам источник, ссылка на заглушку(картинку которая стоит перед этим), ссылка на автора
// Все эти 3 аргумента нам нужно передать в функцию log(). Функция принимает 3 аргумента,а не массив

log(...num); // Разделит массив на аргументы и передаст их внутрь функции

// 4 способ создания поверностных копий объекта. operator spread
const array = ['a', 'b'];

const newAarray = [...array]; // Теперь в переменной newAarray лежит новая копия массива array

// Копия объекта 

const q = {
    one: 1,
    two: 2
}

const newObj = {...q}; // Копия объекта записанная в переменную newObj
// Создаем пустой объект 


// Объектно орентированное программирование. ООП
// Прототипно ориентированное программирование 

// Разные языки используют разные принципы внутри себя. 
// Мы предстовляем любую вещь как объект с набором свойств и методов.

// Когда строка написано просто в ковычках, то это обычный примитив. Простой тип данных 
// Но как только мы пытаемся вызвать какой-то метод или свойства, то JavaScript оборачивает эту строку в объект и после модифицикации возвращает строку обратно
let str = 'some';
let strObj = new String(str);
// Внутрь мы помещаем str на основании строки some мы создаем еще новую строку 
console.log(typeof(str)); // Результат тип string 
console.log(typeof(strObj)); // Результат тип object 

const soldier = {
    health: 400,
    armor: 100
};
const jonh = {
    health: 100,
};
// Нам нужно установить связь чтобы John умел делать тоже самое что и soldier, имел все теже свойства, а некоторые были модифицированны

// Устаревший формат который может встретится. Но уже не используется 
jonh.__proto__ = soldier; // Мы установили прототипом jonh будет soldier - не используется 
console.log(jonh.armor) // Результат 100

// Несмотря на то что у объект jonh только одно свойство, благодаря прототипам он так же получил свойство armor которое было у его прототипа 

Object.setPrototypeOf(jonh, soldier); // Команда получает прототип

// Вскобках пишется тот объект которому будет назначен прототип, а вторым напишем тот объект прототип которого мы устанавливаем

// Обычно когда мы работаем с кодом мы не создаем какие-то ненужные объекты, а потом назначаем прототипы.
// А делаем это на этапе создания объекта

const jonh = Object.create(soldier) // Используется для создания прототипных связей

// Мы создаем новый объект, и на базовом уровне прописать прототип 
// Мы создаем объект jonh который будет прототипно наследоваться от Soldier. Чтобы все также Jonh имел доступ к функциям, методам, свойствам
// Объект jonh еще ничего не содержит, но уже умеет делать все что делает soldier

// ООП - это наука как правильно делать архитектуру. Так же JS можно назвать прототипным языком т.к это частный случай OOП

// Отлавливаем ошибки в коде с помощью консоли разработчика. Breackpoints
/*
- Вкладка Sourse - это вкладка со всеми исходными материалами которые нам доступны в проекте который открыт на странице
- Вкладка Network - отвечает за работу с сетью. Сдель мы можем отслеживать как загружаются скрипты, картинки, HTML структуры
- Но самое главное сдесь мы можем отслеживать запросы которые будут уходит на сайте. Чтобы получить какие-то данные, или отправить данные
- Вкладка performance - мы можем сдесь записать как работает, загружается какая-то структура
- Вкладка Application - можем посмотреть на различные application которые установленны. Например Storage

- Как дебажить наш код?
- Как получать промежуточные результаты которые возникают на том или ином шаге выполнения нашей программы. Для этого у нас существует такая вкладка Source

debugger - в коде является брейкпоинтом. Он останавливает выполнение кода в консоли на себе

Динамическая типизация:
- Это возможность одного типа данных превращатся в другой. Т.е число может стать строкой, строка числом, а объект boolean значением
В мире программирования, в других языках есть и статическая типизация. Когда число всегда остается числом


Варианты 'Что-то превратить в строку' toString

- Старый и очень редко исользуемый способ это команда String
console.log(typeof(String(null))) // string

Команда String взяла и превратила null в строковый тип данных. Просто обернула в ковычки

- Конкатенация

console.log(typeof(5 + '')) // string

const num = 5
console.log('https://vk.com/catalog' + num) - страрый формат который можно встретить

const fontSize = 26 + 'px'

Когда мы что-то складываем со строкой. Это сложение строки с чем-то
При сложении со строкой у нас все равно получается строка


Варианты 'Что угодно превратить в число' Number


- Старый и очень редко исользуемый способ это команда Number
console.log(typeof(number('4'))) // number

- Более простой и удобный способ: Унарный плюс
console.log(typeof(+'5'))

Знак плюс который ставят перед каким-то типом данных

- Метод parseInt
console.log(typeof(parseInt('15px', 10)))


Варианты типизации в Boolean значение

0, '', null, undefined, NaN   // false

Все остальное что есть в JS все будет true

let switcher = null

if (switcher) {
    console.log('Working...')
}

switcher = 1

if (switcher) {
    console.log('Working...')
}

Такой прием мы будем встречать в программах. Что изначально какая-то переменная/переключатель у нас ничего не содержит 
Что в будующем этот перключатель поменяет значение 
Условие не выполнится. Почему?

Потому что мы сейчас обращаемся к переменной switcher. Мы логически ее проверяем, видим что внутри у нас null. null всегда false
Теперь во втором условии все сработает. Т.к в логическом контексте 1 будет правдой

Точно такойже прием используется с элементами на странице. Если у нас какого-то элемента просто не существует вместо него будет null
На одном из этапов у нас на странице появляется этот элемент. Условие узнает что элемент на странице появился
И начинает выполнять какие-то действия

- Вместо Number подстовляем Boolean 
console.log(typeof(Boolean('4')))

- Два знака отрицания дают boolean значение 
console.log(typeof(!!''44444)) 


Работа с DOM деревом: 

- Метод forEach() - работает только когда мы используем querySelectorAll

for (let i = 0; i < hearts.length; i++) {
    hearts[i].style.backgroundColor = 'blue'
}

Чтобы что-то сделать с элементами коллекции (псевдо-массва) обращаемся к массиву hearts
Чтобы получить какой-то элемент ставим квадратные скобки и переменную итератор
Для того чтобы постепенно получать элементы

Т.к мы работаем с определенным элементом, мы можем что-то сделать
Это самый простой цикл который перебирает элементы и позволяет что-то с ними сделать
Цикл мы практически не будем использовать т.к есть перебирающий метод forEach

hearts.forEach(item => {
    item.style.backgroundColor = 'blue'
})
item - так мы назвали переменную в которую по очереди будут помещаться элементы


Основные методы для работы с элементами страницы: 

const div = document.createElement('div')
В нутрь нужно поместить название тега который мы создаем 

const text = document.createNode('') - используется очень редко

Если мы хотим элемент полоность поменять, то чаше всего мы не прописываем целую кучу style или даже не используем css текс
Мы модифицируем css классы элементов 

В реальных проектах мы не будем устанавливать inline стили, а будем работать с css классами 
У нас есть более мощный способо метод classList

classList - где через точку мы можем писать действия с нагим классом
    - добавление .add(): div.classList.add('black') - добавление элементу div класса
    - удаление .remove():
    - переключение:
    - проверка на содержание:
    - определение количества примененных к классу элементов:

Любой элемент вставить в конец, вставить после определенного элемента, удалить или заменить
Но только по отношению к другому элементу

Напрмер: Нам нужно добавить наш div в конец body
document.body.append(div)

Мы берем тег body как родителя и добавляем наш div 
Мы можем вставить не только в body, но и в любого другого родителя

Например в верстке у нас есть плок с классом .wrapper
Если мы хотим вставить новый div в конец блока с классом .wrapper, то нужно получить родитель и дальше исопльзовать метод append()

cosnt addDiv = document.querySelector('.wrapper').append(div) - добавление div в конец элемента родителя
Это очень часто встречающийся способ 

Метод prepend(div) - добавляет элемент в начало элемента родителя
Замена элемента replaceWith

Первый вариант: 
innerHTML - позволяет вставлять внутрь элемента текс, HTML разметку
div.innerHTML = 'Hello world!'
div.innerHTML = '<h1>Hello world!</h1>'

Мы можем абсолютно динамически, при помощь таких строк формировать структуру нашего сайта и сразу же ее туда помещать

Второй вариант: 
textContent - данный тег работает только с текстом

Иногда в данном методе мы получаем от пользователя. Он где-то их ввел, в модальном окне, в каком-то опросе
Если вдруг там используется innerHTML и пользователь введя структуру похожую на HTML может сломать нам верстку 
Таким образом можно вставить сторонний скрипт на страницу

Если нам нужно добавить текстовое содержимое мы используем textContent
Если предпологается работа с HTML структурой мы используем innerHTML

Как нам вставить кусочек HTML кода перед или после определенных тегов для этого есть метод insertAdjacentHTMl

Синтаксис: 
- Сначало мы указыем тег над которым мы будем производить махинации

div.insertAdjacentHTMl('', '<h2>Hello World!</h2>')

Метод принимает 2 аргумента
    - Специальное слово
    - Второй аргумент - это тот HTML который мы хотим вставить в виде строки

Варианты первого аргумента
    - beforebegin - позволяет вставить данный HTML непосредственно перед элементом
    - afterbegin - вставляет HTML в начало элемента
    - beforeend - вставить HTML в конец элемента
    - afterend - вставляет HTML после элемента

hearts = wrapper.querySelector('heart')
- Это значит что в переменную пойдут только те элементы которые подойдут по определенному селектору
И находятся только внутри элемента wrapper

События и их обработчики:
- События это сигнал от браузера о том что что-то у нас произошло

Пример: клик, двойной клик, наведение мыши, убрать мышь с элемента, прокрутка колеса мыши, отправка данных в форме, нажатие клавишь на клавиатуре и тд

Чтобы использовать любое событие мы должны назначить обработчик
Обработчик - это функция которая срабатывает как только событие произошло

Пример: Если пользователь совершает счелчек мыши по меню гамбургер, то у нас срабатывает функция которая открывает это меню


События и их обработчики:
    - В JS у нас всего 3 способа назначить обработчики событий

1. Использовать HTML атрибут который записывается в верстке и в этот атрибут мы можем передать функцию из JS
Мы берем какой-то элемент и в атрибутах прописываем событие с приставкой on. onclick="alert('Click')"
В реальных проектах такой код не используется. Применять его не стоит

2. Использовать свойства DOM дерева для событий

const btn = qocument.querySelector('button');

btn.onclick = function() {
    alert('Click')
}

Если вдруг у вас довольно большой код вот такой обработчик. Но потом забыли что с ним взаимодействовали
И хотим еще добавить какое-то событие, то второй обработчик заменит первый

Иногда обработчики событий нам необходимо удалять, чтобы с элементом больше было нельзя взаимодействовать

3. Метод addEventListenter() 

btn.addEventListener('click', (e) => {
    alert(e.target.remove)
})
callback - такие функция выполняются строго за другими
В данном случае можно вещать несколько обработчиков событий на один элемент

Иногда нам необходимо получать какие-то данные о элементе с которым мы взаимодействуем
Для этого есть специальный объект event. Этот объект передается как аргумент в callback функцию
Если нужно дополнительно передать какие-то аргументы, то объект event всегда должен быть первым аргументов

Чтобы была возможность удалить функцию, ее нужно будет вынести в отдельную переменную
const deleteElemnt = (e) => {
    e.target.remove()
}
btn.addEventListener('click', deleteElemnt) - назначаем обработчик

btn.removeEventListener('click', deleteElemnt) - удаляем обработчик
Обычно метод удаления вызывается в условии. Когда что-то уже произошло


!!! ВАЖНО. Всплытие событий
    - Когда действие срабатывает сначало на вложенном элементе. И после этого поднимается на верх по иерархии DOM дерева
Всплытие событий это когда обработчик сначало срабатывает на самом вложенном элементе, затем на родителе если он у него есть. И так выше и выше

Отмена стандартного поведения в браузере
    - Для отмены стандартного поведения в браузере нам понадобится объект event
Чтобы отменить стандартное поведение мы пишем. event.preventDefault()
Этот участок кода помещается в самое начало

Чтобы вешать событие сразу на нескольких элементах нужно каждый элемент псевдомассива перебрать и на каждый элемент повесить обработчик

btns.forEach(btn => {
    btn.addEventListener('click', deleteElemnt, {once: true})
})

Опции события
    - У addEventListener существует еще и 3 аргумент в который мы можем передать опции


Навигация по DOM-элементам, data-атрибуты, преимущество for/of

document.body.childNodes - узлы которые детьми у body

data-атрибуты
    - Всегда начинаем с data-

for (let node of document.body.childNodes) { - цикл проходится по псевдомассиву
    if (node.nodeName == 'text') {
        continue
    }
}

События на мобильных устройствах
    - Особенность использьвания что в браузере не срабатывают события мыши

В мобильных браузерах есть табы (когда прикасаемся к сенсеру пальцем)

6 событий которые поддерживаются в мобильном браузере
    - touchstart - событие срабатывает при возникновенмя касания к этому элементу
    - touchmove - срабатывает при движении пальца
    - touchend - срабатывает событие как только палец оторвался от элемента
    - touchenter - будет срабатвать когда мы ведем пальцем по экрану и при этом наскальзываем на какой-то элемент на которое повешено это событие
    - touchleave - палец продолжил скользить и ушел за приделы этого элемета
    - touchcancel - возникает тогда когда точка соприкосновения больше не регистрируется на поверхности

DOMContentLoaded - раузер полностью загрузил HTML, было построено DOM-дерево, но внешние ресурсы, такие как картинки <img> и стили, могут быть ещё не загружены.

window.addEventListener('DOMContentLoaded', () => {
    const box = document.querySelector('.box')

    box.addEventListener('touchstart', (e) => {
        e.preventDefault()

        console.log('Start')
    })

    box.addEventListener('touchmove', (e) => {
        e.preventDefault()

        console.log('Move')
    })

    box.addEventListener('touchend', (e) => {
        e.preventDefault()

        console.log('End')
    })
})

3 главных свойства при работе с сенсорными устройствами
    - touches - выдает список всех пальцев которые сейчас взаимодействуют с экраном
    - targetTauches - все пальцы которые взаимодействуют с этим элементом
    - changedTouches - список пальцев которые участвуют в текущем событии


Async, defer, динамические скрипты

defer - этот атрибут сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме
Скрипты с defer никогда не блокируют страницу. Несколько скриптов будут загружаться по очереди
Скрипты с таким атрибутов всегад выполняются когда наше DOM дерево уже готово
Срабатывает еще до DOMContentLoaded


async - 
Страница не ждет ассинхронных скриптов содержимое просто обрабатывается и отображается 
Событие DOMContentLoaded и ассинхронные скрипты не ждут друг друга

Если мы ставим атрибут async скрипт начинает загружаться как только до него доходит страница, загружается в фоновом режиме
При этом запускается как только он был загружен. Он никого не ждет

Иногда мы будем подключать какие-то сторонние скрипты которые не сильно подвязаны под DOM структуу и под функциональность
Например метрики и счетчики

Вывод:  
    - Когда мы используем скрипты с атрибутом async мы должны быть точно уверены, что это скрипт не зависит от DOM структруы
Ему все равно сформировалась ли она или нет. Он должен не зависеть от других скриптов. Он загрузился и сразу выполнился 

const script = document.createElement('script')
script.src = 'js/test.js'
script.async = false
document.body.append(script)












































































































































































































*/