/*
Redux
    - это библиотека для работы с состоянием приложения
Проше говоря это некоторое хранилище данных 

Какую проблему решает Redux?

Есть некоторое дерево компонентов в корне которого лежит компонент <App/>
Внутри нее находятся еще несколько компонентов которые содержат также несколько компонентов
И может возникнуть такая ситуация когда состояние из компонента в ветке 1 может понадобится в компонент ветки 2

Да, можно вывести это состояние в родительскую компоненту и передавать через параметры т.е через props
В больших проектах это сильно запутывает код. Становится сложно искать какие-либо данные 


Состояние выносится во внешнюю зависимость и каждый компонент получает какие-то данные уже из этого состояния
Во первых состояние которое используется в одной компоненте можно использовать и в другой
Во вторый просто хорошей практикой считается хранить данные и логику которая с ними взаимодействует отдельно от компонента


Почему плохо хранить состояние прямо в компоненте?
    - Сложно будет строить взаимодействие между одним компонентом и другим компонентом 
Потому-что у каждого есть свое локальное состояние и в конечном итоге такой подход не будет масштабируемым
Рано или поздно мы запутаемся в том как это состояние связано, как состояние влияет на другое место в коде 


Создание Redux

import { createStore } from './createStore'

const store = createStore() - Создание store. Глобальное хранилище

Чтобы он заработал нужно экспортировать createStore который мы создадим в другом файле
Теперь мы знаем что вызывая переменную store мы должны получить объект store который умеет взаимодействовать с данными 
Говорить нашему компоненту что в нем что-то изменилось 


Создание store: - использует в основе паттерн Observer

expot function createStore(rootReducer, initialState) {
    let state = rootReducer(initialState, { type: '__INIT__'})
    const subscribes = []

    return {
        dispatch() {
            state = rootReducer(state, action)
            subscribes.forEach(sub => sub())
        },
        subscribe(callback) {
           subscribes.push(callback) 
        },
        getState() {
            return state
        }
}

У Redux store присутсвует несколько базовых метода

dispatch() - метод говорит что нужно что-то изменить
subscribe() - говорит что все слушатели которые слушают этот объект они должны что-то поменять

Мы используем реализацию через функцию, делается это для того чтобы мы пользовались всей мощью замыканий
По умолчанию в большинстве форматов языка JS нет приватных переменных, а благодаря замыканиям мы можем их получить 

return {} - возвращает публичные методы

То что пишеться внутри самой фукнции будет не доступно для тех кусков кода которые будут использовать данный store
Создаються приватные вещи например переменная state
И сразу мы можем реализовать метод getState(). Т.е это публичный метод позволяющий получить этот state

Несмотря на то, что это приватная переменная, благодаря этому getter мы можем получить состояние
Чтобы потом понимать в какой состоянии находится наше приложение

В subscribe(callback) мы передаем функцию которая выполнится тогда когда что-то произойдет
Но, чтобы что-то произошло нам нужны сами слушатели subscribes

Когда мы подписываемся на store мы складываем в subscribe callback и ничего не делаем 

В dispatch(action) мы принимаем некоторый action

action - по сути равен обычному объекту у которого есть обязательное поле type
Состояние мы меняем через reducer

Нам важно понимать что когда прилитает action мы должны изменить наш state и сделать это должны череp reducer
Для каждого приложения должен быть свой reducer. Мы принимаем его как параметр

rootReducer - это функция которую мы можем вызвать и передать action. Первым параметром передаем state
т.е предыдущее состояние которое у нас есть


Правило reducer заключается в том что вы на выходе получаем объект
Мы что-то прогоняем через reducer передавая в него state и action и получаем новый state

Дальше нам нужно уведомить всех наших слушателей что состояние изменилось
subscribes.forEach(sub => sub())

Мы пробегаемся по массиву subscribes и каждый элемент этого массива это функция которую мы можем вызвать
Получается в редаксе всего 17 строчек кода


По умолчанию мы всегда state задаем пустой объект. Но пустой объект это не всегда начальное состояние
let state = rootReducer(initialState)
Первым параметром он принимает в себя состояние 
initialState - это начальное состояние


const store = createStore(rootReducer, {
    counter: 0
})
Чтобы наш стейт окончательно работал нам нужно передать некоторый rootReducer

Мы создадим новую папку redux
В чем заключается идея. В том что логику нашего приложения мы выносим в отдельный файл который не связан с нашим компонентом
В этой папке мы создаем rootReducer.js


reducer - это просто обычная функция которая первым параметром принимает в себя state которые мы передали в rootReducer в Store

export function rootReducer(state, action) {
    if (action.type === 'INCREMENT') {
        ruturn state + 1
    } else if(action.type === 'DECREMENT') {
        return - 1
    }

    return state
}
rootReducer по умолчанию всегда должен возвращать нам state. Т.е вернуть нам новый объект
Учитывая то, что action это обычный объект у которого есть поле type, то здесь мы просто можем понимать какой именно action нам приходит 
т.е что конкретно нам нужно сделать. И в зависимости от этого action менять наше состояние 

{} - вторым параметром идет объект, это начальное состояние 
Reduce - пробегается по action.type и если он находится в определенном состоянии, то изменяет его
Если он не находит if, то возвращает старое состояние

У нас есть глобальный объект который мы меняем с помощью dispatch()

addBtn.addEventListener('click', () => { - Прибовляет 1
    store.dispatch({ type: 'INCREMENT' })
})
subBtn.addEventListener('click', () => { - Прибовляет 2
    store.dispatch({ type: 'DECREMENT' })
})

Как нам понять в компоненте что что-то изменилось?

Учитывая что store идет по паттерну Observer, то мы можем подписаться на эти изменения 

store.subscribe(() => {
    const state = store.getSate()

    counter.textContent = state
})
Мы подписываемся на наш store. Подписываемся на какие-либо изменения в нем и дальше получаем сам state
И дальше мы можем отрисовать в шаблоне
Вся логика изменений находится в rootReducer

Чтобы после перезагрузки страницы у нас по умолчанию было значение нужно
store.dispatch( {type: 'INIT_APLICATION'})


Работа с библиотекой Redux:
    
import { createStore } from 'redux'

action.creater - посути это обычные функции которые умеют создавать нам определенные actions

import { INCREMENT, DECREMENT } from './types'

export function increment() {
    return {
        type: INCREMENT
    }
}

export function decrement() {
    return {
        type: DECREMENT
    }
}

Проблема ассинхронности в Redux. Поэтому существует такой концепт middleware
applyMiddleware(thunk, logger)
Теперь мы можем создавать ассинхронные action-creater

export function asyncIncrement() {
    return function(dispatch) {
        setTimeout(() => {
            dispatch({type: ASYNC_INCREMENT})
        }, 1500)
    }
}

Базовый пример middleware
    - это обычная функция которая принимает в себя state
Но дальше эта функция должна вернуть новую функцию 

function logger(state) {
    return function(next) {
        return function(action) {
            next(action)
        }
    }
}

Принимает параметр next 
Правило говорит что мы в последней функции должны вернуть результат работы функции next с action





*/