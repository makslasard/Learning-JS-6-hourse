/*
Redux - обучение на Stepik

Основная идея: 
    - Что без Redux наши компоненты могут как-то взаимодействовать, но они взаимодействуют по цепочке

И если мы создаем много компонентов с определенным уровнем вложенности, то часто бывает что через props пробрасываеться информация 
    от компонента к компоненту при этом она может не использоваться по пути - такая проблема называеться Props Drilling

Т.е просверливать props - ми сквозь компоненты где они не нужны. Это не удобно
Если например props создан на уровне App и нужно его переименовать на большой вложенности, то придеться переименовывать props по всей цепочке

    - С Redux все данные на уровне приложения который должны глубоко опускаться и использоваться. Они выносяться на уровень некоторого общего хранилища
Которое называется store. И с store может взаимодействовать абсолютно любой компонент без необходимости пробрасывать что-то через props

Она не отменяет props как таковые, мы продалжаем ими пользоваться там где это уместно
Но там где цепочка может быть сложной мы храним информацию в store и получаем его на прямую с любого уровня и любого компонента


Варианты state managment для React: 

    - Context встроеный в React инструмент
Инструмент который позволяет из некоторого контекста получить нужную информацию. При этом мы не устанавливаем никаких дополнительных библиотек,
    наш итоговый bundle не утяжеляется. Используеться на маленьких иногда на средних проектах

    - recoil 
С точки зрения веса самое лайтовое. Делает по сути тоже самое только по своему

    - MobX 
Обычно любят разработчики которые предпочитают ООП

    - Xstate

    - Эффектор от Российских разработчиков
Предпологает более декларативный подход

Три принципа Redux:

    - У нашего проекта должен быть единый источник правды
Предпологаеться что у нас есть некий глобальный state (глобальное хранилище). Информация о котором потребляется нашими компонентами и при этом
    не дублируеться в самих компонентах. Нельзя чтобы в redux и в компоненте были разные данные 

Вся та информация которая должна разделяться между разными компонентами она в большинстве своем будет храниться в redux

    - Наш state (объект store) он дается только для чтения
Любой компонент потребляет информцию которая есть в объекте store, читает её, но не может ее модифицировать на прямую
Перезаписывать мы будем через специальные сущности которые называются actions
Только через actions мы можем как-то изменить наше состояние приложения. Логику action мы будем писать не в самих компонентах
    в компонентах мы будем вызывать эти события

    - Обрабатываются actions в такой сущности как reducer
Это по сути просто фукнции. Но эти функции должны быть чистыми т.е ведут себя предсказуемо. Выдавать одинаковый результат при одинаковых входных данных
Чистые функции не имеют side effects это значит что полученные объекты будь-то state, или что-то еще они их не мутируют, они их только читают

Базовы сущности Redux:

    Наше приложение работает с какими-то данными. Наши компоненты из Store в любом колличестве получают данные. На основании данных отрисовывают 
представление которое доступно пользователю. Пользователь может что-то сделать

    Любое действие пользователя может привести к определенному событию action
Action - это объект. Объект содержит информацию о типе события и какую-нибудь сопроводительную информацию

    На основании информации которую содержит обхект action, наш reducer - это некоторая функция должен преобразовать в наш store
Reducer можно представить в виде фильтра. Это фукнция которая всегда принимает наш store, конкретное событие и отталкиваясь от
конкретного события по условию делает то или иное действие. И всегда возвращает новый store. Обновляеться набор данных


Базовое API в Redux:







*/