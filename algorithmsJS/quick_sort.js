/*
Быстрая сортировка или сортировка Хоара:
    - Алгоритм работает за O(log * n) и является рекурсивным

Работает по принципу "Разделяй и властвуй"
    - Мы делим массив на подмассивы и каждый раз рекурсивно мы выбираем опорный элемент у каждого массива
Его можно выбрать случайно, но чаще всего берут центральный 

    - Пробегаемся по массиву и все элементы которые по значению меньше чем опроные добовляем в один массив,
которые больше добовляем в другой массив

После такой операции у нас получаеться 2 массива с меньшими и с большими чем опорное
Для каждого из этих массивов выполняеться точно таже операция в каждом из этих подмассивов выбираеться элемент
    и происходит сортировка. 

И так делаеться до сих пор пока длинна массива не станет равна 1
Именно это условие будет базовым случаем выхода из рекурсии

И после всех операций маленькие отсортированные подмассивы склеиваются в один большой

Програмная реализация:
    - Сразу же зададим базовый случай при котором рекурсия будет заканчиваться 
В нашем случае если длинна массива меньше или равна 1

    - Затем нужно найти опорный элемент
Сначала получим индекс этого элемента
Длинну массива делим на 2 и с помощью Math.floor округляем это значение чтобы не было дробных чисел

    - Затем получаем из массива сам опорный элемент 
Для этого мы обращаемся к элементу по индексу который мы высчитали

    - Также нам необходимо 2 массива
В один мы будем сохранять числа которые меньше чем опорные, в другой больше чем опорные

    - Затем мы должны пробежаться по массиву и сравнить каждый элемент с опорным

Внутри будет 3 условия

    1. Сравним индекс текущей иттерации в цикле с индексом опорной точки
И если они равны мы пропускаем иттерацию continue

    2. Если текущий элемент иттерации меньше чем pivot мы будем добовлять его в массив less
Т.е это число меньше опорного

И таким образом после полного прохождения по циклу у нас получиться 2 массива. С числами которые больше, 
    и с числами которые меньше. 

Также мы должны верунть массив return [...quickSort()] и также в этот массив мы разворачиваем 
    рекурсивно выполнение функции quickSort в который мы передаем левый подмассив с числами меньше опорного

По середине мы вставляем сам pivot. А с права подмассив больше опорного

Таким образом каждая из этих подфукнций которая будет выполняться рекурсивно 

И по итогу склеиваются в один большой массив




*/
const arr = [0, 3, 2, 5, 6, 8, 1, 9, 4, 2, 1, 2, 9, 6, 4, 1, 7, -1, -5, 23, 6, 2, 35, 6, 3, 32]
let count = 0

const quickSort = (array) => {
    if (array.length <= 1) return array

    let pivotIndex = Math.floor(array.length / 2)
    let pivot = array[pivotIndex]
    let less = []
    let greater = []

    for (let i = 0; i < array.length; i++) {
        count += 1
        if (i === pivotIndex) continue

        if (array[i] < pivot) {
            less.push(array[i])
        } else {
            greater.push(array[i])
        }
    }
    return [...quickSort(less), pivot, ...quickSort(greater)]

}


console.log(quickSort(arr))
console.log(count)

function quickSort(array) {
    let pivotIndex = Math.floor(array.length / 2)
    let pivot = array[pivotIndex]
    let less = []
    let greteas = []

    for (let i = 0; i < array.length; i++) {
        if (i === pivot) continue

        if (pivot < array[i]) {
            less.push(array[i])
        } else {
            greteas.push(array[i])
        }

    }

    return [...quickSort(less), pivot, ...quickSort(greteas)];
}

const queue = (arr) => {
    const queue = []

    for (let i = 0; i < arr.length; i++) {
        if (queue.length === 0) {
            
        }

        if (arr[i] % 2 === 0) {
            queue.push(arr[i])
        } else {

        }

    }

    return queue
}
queue([1, 2, 3, 4, 5, 6])