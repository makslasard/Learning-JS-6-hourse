/*
Алгоритмы и структуры данных:

Самые часто используемые алгоритмы и структуры:

Алгоритмы:
    - Поиск
    - Сортировка
    - Рекурсивные
    - Дейкстры для поиска кратчайшего пути в графе
    - Обход деревьев
    - Кеширования

Структуры:
    - Массивы
    - Связный список
    - Очередь
    - Стек
    - Мэп
    - Двоичное дерево
    - n - арное дерево
    - Графы

Алторитм
    - это набор последовательных действий которые решают какую-то задачу. В принципе любой фрагмент кода можно назвать алгоритмом

Оценка сложности алгоритмов:
    - некоторые алгоритмы являются эффективнее чем другие 

               O (n)
    O - большое     n - кол-во операций

Эффективность не всегда равна скорости работы алгоритма. Поскольку в некоторых ситуациях более медленный алгоритм на определенной выборке данных
    более эффективным. 

Сложность алгоритма или же его скорость в теории алгоритмов описываеться специальной аннотацией O - большое

Пример:
               O (n)
    O - большое     n - кол-во операций

В скобках указывается колличество операций за которое данный алгоритм приходит к финальному результату
Причем указывается всегда наихудьшая ситуация

Также представить сложность алгоритмов можно представить в виде графиков

Примеры функций которыми чаще всего описываеться сложность алгоритмов:
    - где по оси X - колличество операций, а по оси Y - время

    - O(Log2n)
    - O(n)
    - O(n*log2n)
    - O(n*n)
    - O(n!)

Каждый последующий график растет все быстрее и быстрее
Это говорит о том что скорость работы алгоритма очень низкая и в случае последнего графика O(n!) существуют задачи решение которых настолько долгое
    что их в принципе не возможно решить на данный момент

Пример:

[7 6 1 4 0 2 3 5 8 5]

Представим что у нас есть массив состоящий из 10 элементов
И нам нужно реализовать алгоритм который будет искать в данном массиве определенный элемент

Один из алгоритмов называется Линейный поиск: 
    - мы начинаем с первого элемента и последовательно каждый элемент сравниваем с тем который ищем

В лучшем случае мы найдем элемент за одну операцию 
В худшем случае мы найдем элемент в самом конце списка и нам нужно будет пройтись по каждому элементу который в этом списке находится

Оценка сложности производится по худшему сценарию поэтому сложность данного алгоритма будет O(n) где n - кол-во элементов в массиве
т.е для массива из 10 элементов мы сделаем 10 операций из массива в 1 000 000 элементов 1 000 000 операций

Бинарный поиск: 
    - он работает в разы быстрее, но изначально подразумевается что массив отсортирован по порядку 

[1 2 3 4 5 6 7 8 9 10]

Работает по принципу деления на 2

Например: ищем 7
    - делим массив пополам и наш взор падает на 5
Элемент больше чем 5? ДА. Значит левую часть массива мы сразу же откидываем и работаем с правой

    - делим массив пополам и наш взор падает на 8 - [6 7 8 9 10]
Проверяем 7 меньше 8? Да. Осеиваем правую часть массива

    - делим массив пополам и натыкаемся на 7
Искомый элемент найден

Сложность такого алгоритма O(log2n)

Линейный поиск работает за линейное время
Бинарный поиск работает за логарифмическое время

Сравнение: 
    - Если считать 1 операцию за 1 мс

Линейный:
    - 100 элементов - 100 мс
    - 10 000 элементов - 10 сек
    - 1 000 000 элементов - 11 дней

Бинарный:
    - 100 элементов - 7 мс
    - 10 000 элементов - 14 мс
    - 1 000 000 элементов - 32 мс

Эффективней оказывается бинарный алгоритм
Поэтому важно понимать когда и где использовать тот или иной алгоритм и насколько он будет эффективней для конкретной задачи

Но также важно понимать что бинарный алгоритм работает только с отсортированным списком 
Если использовать его на не отсортированном списке вероятнее всего мы ничего не найдем и выйгрыша по времени не будет

И сортировать массив чтобы применить данный алгоритм не имеет смысла т.к время сортировки гораздо длительней работы линейного поиска




































































































*/