/*
Алгоритм Дейкстры - поиск кратчайшего пути в графе
    Если в поиске в ширину мы находим кратчайший путь передвигаясь по вершинам графа, то не важно длительный ли 
        это путь или нет. Самой главное это кол-во пройденных участков

        В алгоритме Дейстры учитываеться еще и длина пройденного ребра так называемый вес

    На рисунке мы можем заметить, что путь который мы искали поиском в ширину, в данном случае оказыаетсья не 
        самым быстрым. Поскольку расстояние от D до F целых 7 единиц. И в данной ситуации необходимо
        воспользоваться алгоритмом дейкстры чтобы высчитать оптимально короткий путь и добраться до пункта назначения
        за кратчайший промежуток времени

Логика работы алгоритма:
    
    1. За стартовую точку принимаем A за конечную G

    2. Составляеться табличка в которую на первом этапе записываються значения тех вершин в которые мы 
        можем попасть из стартовой точки. Все остальные вершины являются не достежимыми и мы их 
        помечаем знаком бесконечности
    
    3. На втором этапе мы помечаем данные вершины как уже рассмотренные

    4. На третьем этапе мы рассматриваем вершины в которые мы можем попасть из точек B и С
        и в таблицу записываем значения, от точки A до точек которых мы достигаем из вершин B и C
        Опять же помечаем эти точки как уже рассмотренные 

    5. На следующем этапе мы достигаем точки G. Но у нас происходит перерасчет мы находим путь до точки F
        которая оказываеться короче и перезаписываем значение в таблице

    6. На следующем этапе мы проделоем тоже самое и находим самый оптимальный путь и узнаем что
        в точку G мы можем добрать за 5 условных едениц

Программная реализация:

    1. Теперь каждой вершине графа соответствует не массив, а объект
        C расстоянием до двух вершин

    2. Создаем функцию параметром которой будет граф, начальную точку, и конечную точку

    3. Внутри создадим объект. Это будет та самая таблица в который мы будем хранить кратчайшие пути 

    4. Далее создадим массив. Это будет массив в который мы будем добавлять те узлы которые мы уже проверили

    5. Создадим еще один объект. В нем мы будем хранить соседние вершины рассматриваемого узла

    6. Далее мы должны заполнить таблицу и заполнить те вершины в которые мы можем добратся из стартовой точки
        значениями, а остальные заполнить каким-то большим числом

        Поэтому у нашего крафа получаем список ключей это как раз будут все вершины и иттерируемся по ним
    
    7. Проверим если текуший элемент иттерации (т.е вершина) не равна стартовой, то соответственно 
        мы будем заполнять значения. Т.е стартовая вершина в эту таблицу не добавляеться 

    8. Теперь получим значение
        Поскольку графф масс объект у которого есть поля где каждое поле это вершина. И каждое поле также 
            является объектом у которого тоже есть какие-то значения, то это значение мы пытаемся получить
            у стартовой позиции в данном случае у вершины A и получить значение вершины либо B либо C

            Затем это значение нужно добавить в табличку в которой будут храниться значения кротчайших путией
            Если value мы нашли, если из точки A в эту вершину есть путь, то тогда мы добавляем это значение
            В ином случае мы добавляем бесконечно большое число

    9. Чтобы понять что на данный момент там храниться попробуем вывести функцию в логи
            И получаем что из A у нас есть путь из B и C, а все остальные значение мы заполнили большим числом
            поскольку из вершины A в эти точки пути нет

    10. Следующим этапом нам нужно найти вершину в которую на данный момент мы можем попасть из точки A и путь
            в которую самый коротки

            Для этого реализуем функцию, условно назовем ее найти узел с минимальной стоймостью
            Параметрами передаем объект с стоимостью всех путей и массив с уже обработанными узлами 
            findNodeLowestCost

            Внутри создаем 2 переменные: 1. Будет хранить минимальное значение по умолчанию делаем больним
                числом - 100000000. И ноду которую по итогу мы будем возвращать с минимальным значением
            
            Теперь нужно проитеррироваться по ключам объекта в котом мы храним стоимость путей
            Для более локаничной записи воспользуемся фунцией forEach и первым делом получим стоимость 
                текущей ноды. Стоимость мы получаем по ключу из объекта costs

            Затем в условии проверим. Если эта стоимость которую мы получили меньше чем минимальная стоимость
                которую мы определили в самом начале и вершина которую мы рассматриваем на текущей иттерации
                не находится в массиве обработанных вершин в этот массив вершин мы будем добавлять чуть больше

            Если условие выполнелось получаеться мы нашли новый объект у которого путь короче
            Соответственно мы перезаписываем минимальную стоимость на ту которую мы нашли на этой иттерации
                и заменяем ноду

            Мы сравниваем стоимость. Если она меньше и узел еще не обработан, то мы обнавляем переменные

            И по итогу на выходе из этой функции необходимо вернуть вершину с минимальной стоимость

            Итак мы вызываем эту функцию. Получаем объект с минимальной стоимостью. И далее мы делаем
                цикл while который будет крутиться до тех пор пока нода не пустая. Т.е до тех пор пока мы не 
                обойдем весь графф

            На каждой иттерации мы получаем стоимость текущей вершины. И те узлы в которые мы можем попасть
                из этой вершины мы присваиваем тот объект который мы создавали для соседних вершин

            Это делается для того чтобы мы могли по ним проитеррироваться

            Теперь получаем ключи у этого объекта и с помощью цикла forEach иттерируемся по массиву который 
                вернет нам эта функция. Сдесь мы будем высчитывать новую стоимость. Т.е если до какого-то 
                узла мы можем добраться коротким путем, то соответсвенно в таблице нам нужно это значение перезаписать

            И в условии проверяем если эта новая стоимость меньше чем стоимость которая лежит в нашей таблице
                для этого узла, то эту стоимость необходимо перезаписать

            Таким способом иттеративно мы находим минимально коротки пути и перезаписываем в нашей таблице
            Теперь вершину которую мы рассматривали на данной иттерации необходимо добавить в массив
                также обработанных вершин

*/

const graph = {}
graph.a = { b: 2, c: 1 }
graph.b = { f: 7 }
graph.c = { d: 5, e: 2 }
graph.d = { f: 2 }
graph.e = { f: 1 }
graph.f = { g: 1 }
graph.g = {}

function shortPath(graph, start, end) {
    const costs = {}
    const processed = []
    let neighbors = {}

    Object.keys(graph).forEach(node => {
        if (node !== start) {
            let value = graph[start][node]
            costs[node] = value || 100000000
        }
    })
    let node = findNodeLowestCost(costs, processed)

    while (node) {
        const cost = costs[node]
        neighbors = graph[node]

        Object.keys(neighbors).forEach(neighbor => {
            let newCost = cost + neighbors[neighbor]
            if (newCost < costs[neighbor]) {
                costs[neighbor] = newCost
            }
        })
        processed.push(node)
    }
}

function findNodeLowestCost(costs, processed) {
    let lowestCost = 100000000
    let lowestNode

    Object.keys(costs).forEach(node => {
        let cost = costs[node]

        if (cost < lowestCost && !processed.includes(node)) {
            lowestCost = cost
            lowestNode = node
        }
    })
    return lowestNode
}

shortPath(graph, 'a', 'g')


const graph = {}

graph.a = ['b', 'c']
graph.b = ['f']
graph.c = ['d', 'e']
graph.d = ['f']
graph.e = ['f']
graph.f = ['g']

const searchBreath = (graph, start, end) => {
    let queue = []
    queue.push(start)

}

searchBreath(graph, 'a', 'g')


