// use strict - строгий режим. Все сценарии работают в современном режиме.

//--------------------Простое общение с пользователем-------------------//

const result = confirm('Пользователь, ты еще сдесь?'); // confirm появляется в модальном окне, с двумя кнопками 'OK' или 'Отмена'. 
// Дает возможность пользователю совершить выбор 'ДА' или 'НЕТ'
// Результат выбора пользователя помещаеться в переменную в формате boolean. result = true / false;

const answer = prompt('Вам есть 18?', '18');
// Первое значение это вопрос который мы спрашиваем у пользователя. 
// Второе значение это дефолтный ответ от пользователя. Если нет стандартного ответа ковычки пишутся всегда пустые
// Результат ответа пользователя будет помещен в переменную. 
// В любом случае чтобы не ответил пользователя значением будет тип данных строка

// ВАЖНО!!! Вся информация которая приходит от пользователя всегда приходит в виде строк. В независимости как вы ее получили. 
// Если к prompt поставить + (+prompt) - то число будет типа number. Это так называемая динамическая типизация
// В данном случае мы строку преобразовали в число

const answers = [];
// answers[0] = 'Первый элемент массива!'; // С помощью квадратных скобок можно не только получить значение , но и записать его
answers[0] = prompt('Ваше имя?', ''); 
answers[1] = prompt('Ваша фамилия?', '');
answers[2] = prompt('Сколько вам лет?', '');

// Команды которые мы используем в этом уроке нужно тестировать только внутри браузера. Так как внутри терминала таких команд просто нет

//--------------Интерполяция-----------------//
// Это значит что мы прямо внутри строки можем вставлять значение переменной ${category}
// Прием интерполяции был придуман чтобы не склеивать большое колличество значений в одну строку. 
// Можно использовать только с обратными ковычками ``. 
const category = 'toys';
console.log(`https://someurl/${category}/5`);
// Значение переменной может нам прийти откуда угодно из базы данных, скрипта, и т.д

//------------Операторы JS---------------//
let incr = 10,
    decr = 10;

incr++; // Оператор инкримента т.е увеличение на 1
decr--; // Оператор дикремента т.е уменьшение на 1

++incr; // Когда оператор ставиться перед переменной называеться префиксным, когда после тогда постфиксный
--decr;
// Когда мы использует инкримент и дикремент в постфиксной форме прям сразу, то код исполняеться с лева на право. 
// Поэтому сначало получаеться старое значение которое выводится в консоль, а потом начинаеться сложение 
// Чтобы сразу использовать икримент нужно использовать префиксную форму

// Знак процента в JS возвращает остаток от деления 5 % 2 = 1;

// && - 'И' : работает только тогда когда 2 и больше подоных является true
// || - или : работает когда один из вариантов будет true

//------------Условия---------------// Урок.13
// Добавленная информация содержится в основном обучающем JS файле

// Конструкций switch case
const num = 50;

switch (num) { // В условие мы помещаем объект того что мы будем сравнивать, что проверять
    case 49: // Прописываем дерективу case и указываем, то значение которое мы хотим проверить 
        console.log('Неверно');
        break;// После каждого условие нужно прописывать ключевое слово break. Это обязательная синтаксическая конструкция. 
    case 100:
        console.log('Неверно');
        break;// Если мы пишем слово break на этом все закончится 
    case 50:
        console.log('В точку');
        break;
    default: // Если не одно из условий не выполниться , то сработает default действие по умолчанию 
        console.log('Не в этот раз!');
        break;
}
// Конструкция switch всегда идет на строгое сравнение в отличие от обычных условий. Проверяем только на строгое соответствие 

//---------------Цикл-----------------//

// Используется для повторения однотипных действий

/*const num = 50;
while (num < 55) {
    console.log('num');
    num++;
};*/

/*do { // Сначало выполняется какое-то действие, а потом проверяется условие
    console.log('num');
    num++;  
}
while (num < 55)*/

// Самый часто использующийся

for (let i = 1; i <= 8; i++) {
    if (i === 6) {
        break; // Ключевое слово полностью завершает работу цикла
        // continue - оператор позволяет пропустить шаг который нам не нужен
    }
}
// Условие цикла состоит из 3х параметров: 1. С чего начнется цикл. 2.Условие при котором наш цикл остановит свою работу
// 3. Мы записываем шаг цикла
// Именно цикл позволяет работать с большим количеством элементов 20,30,40 и тд

// Функции
let num = 20;

function one(text) { // Мы можем передать параметры которые функция может использовать внутри себя
    console.log(text, arg, num)
    let num = 10 // Не отображается т.к итератор ее не видит
}
one('Hello world!'); // Параметр будет подстовлятся вместо text
console.log(num); // 20  - т.к num через значение у глобальной переменной , про переменную внутри функции интерпритатор не знает
// Аргументов может быть бесконечное количество
// Переменная которая создана глобально может использоваться внутри других функций

// Замыкание

// Это сама функция вместе со всеми внешними переменными которые ей доступны

// Когда у нас внутри какой-то функции есть обращение к какой либо переменной
function one(text) { 
    console.log(text, arg, num)
    console.log(num); 
}
// Если переменная num не находит для себя значение внутри функции , то она поднимается для поиска на уровень выше 
// Где и находит глобальную переменную. Идет до конца до самого высшего уровня

function ret() {
    let onn = 60;

    // Выполнение большего кол-во кода

    return onn;
}

const onnON = ret();
// Виды функции

// Function Declaration 
function foo() {

}
// Создается до начала выполнения скрипта, можно вызвать перед объявлением

// Function Expression
let foo = function() {

}
// Создается только тогда , когда доходит поток кода, можно вызвать только после объявления

// Стрелочные функци
//() =>
// Не имеют своего контекста
const calc = ( a,b ) => {
    console.log('1')
    return a + b
}
// Методы и свойства строк и чисел

const str = 'Hello!'
const arr = [1, 2, 3] 
console.log(arr.length) // length - это единственное свойство
// Все методы пишутся с круглыми скобками т.к они выполняют какое-то действие над строкой метод() 

// indexOf - ищет элементы в строке . Если результат -1 , то такой кусочек строки не был найден
// slice - Вырезает от одного элемента до другого . Задаем 2 значения: 1. С какой части строки нужно что-то возвращать. 2. До какого элемента вырезать
// Не включая последний элемент (1, 7) - вырежет с 1 по 6
// Метод поддерживает и отрицательные значения, и начинается с конца

// Метод substring похож на slice. Принимает в себя start и end
// Метод substr отличается что 2 аргумент принимает в себя количество символов которые нужно вырезать substr(1, 5);

// Методы работы с числами
// Math - math.round() округляет число до ближайшего целого
// parseInt - переводит число в другую систему исчисления. Может обрезать число и превратить в числовой тип данных
// parseFloat - взять число или строку и вернуть в десятичном варианте. Возвращает значение с плавающей точкой

// callback - функции

function start ( ) {
    // Выполняеться какой-то код. Загрузка данных с сервера, или обработка файлов
    setTimeout(function() {
        console.log('Загрузка с задержкой в 0.5 секунды!')
    }, 500) // Для примера работы задержки
}
// Функция в себе имеет задержку
// Из за задержки функция при выполнении будет не видна , т.к сначало выполнется функция без задержки

function second() {
    console.log(2)
}

start();
second();
// Если функции в коде идут одна за другой, это не значит что они дадут результат в одно время

// callback - это функция которая должна быть выполнена после того как другая функция завершила свое выполнение 
function learnJS(lang, callback) {
    console.log(`Я учу: ${lang}!`)
    callback();
}

function todo() {
    console.log('Я прошел этот урок!')
}

learnJS('JavaScript', todo)
// Передаем аргумент callback - это главный шаблон callback функций
// Что в будующем через аргумент callback мы сможем передать другую функцию
// После выполнения первого действия выполниться строго вторая функция
// Всегда должна сохранятся последовательность функций

// Если в дальнейшем нам нужно будет использовать функцию callback 
// При вызове todo мы не ставим () - скобки т.к мы передаем функцию , а не вызываем. Чтобы в дальнейшем она была использована
// callback функции позволяют нам быть уверенным в том что определенный код не начнет исполнение до того момента пока другой код не завершит свое исполнение

// Объекты, деструктуризация объектов
const obj = new Object();  // Создаем новый объект. Зачастую никогда не используется 

const options = { // Объект заполняется в формате  ключ: значение 
    name: 'Ivan',
    width: 1024,
    heigth: 1024,
    color: {
        border: 'black',
        bg: 'red'
    }
};
// Оператор delete - удалить что-то
delete options.name;
// Для перебора методов в объекте используется цикл for in. Возвращает значение в формате ключ: значение
// Цикл for in будет отрабатывать столько раз, сколько методо у нас в объекте 
let counter = 0;
for ( let key in options) {
    if (typeof(options[key]) === 'object') { // 
        for (let i in options[key]) { // Перебор объекта внутри объекта
            console.log(`Свойство ${i} имеет значение ${options[key][i]}`); // i используется чтобы достучатся до методов внутри color
            counter++; 
        }
    } else {
        console.log(`Свойство ${key} имеет значение ${options[key]}`);
        counter++; 
    }
    
};
// При простом переборе итератор не сможет отобразить object color и выведет [object object]
// Чтобы этого избежать мы создадим итератор внутри итератора
// console.log(options['colors']['border']);

// Рекурсия - это когда функция вызывает сама себя
// У объекта нет свойства length , поэтому мы будем создавать счетчик для подсчета

//Object.keys() - берет наш объект и на его основании создает массив  в котором все элементы ключи находящиеся в объекте
// [ 'name', 'width', 'height', 'color' ] - у получаемого массива мы можем использовать свойство length
// console.log(Object.keys(options).length)

// Мы можем создават такие методы вручную
/* 
const options = { 
    name: 'Ivan',
    width: 1024,
    heigth: 1024,
    color: {
        border: 'black',
        bg: 'red'
    },
    makeTest: function() { // Мы создали свой метод который будет работать внутри options
        console.log('Hello!')
    }
};
*/
// Метод это действие которое умеет совершать наш объект
// Чтобы запустить метод: options.makeTest(). Если ставятся круглые скобки, значит что-то идет в работу
// Объекты это тип данных который может сохранять в себе любые типы данных в формате ключ: значение. Так же объекты могут быть вложены в объекты
// Чтобы перебрать объект нужно использовать for in
// Чтобы наш объект умел что-то делать мы можем создать функции ( методы )

// Так же ты можешь встретить в работы так называемые методы аксессоры - это get и set

// Деструктуризация объектов
// Мы будем вытаскивать переменные в качестве отдельных структур, которые мы будем выносить за наш объект и как-то уже в дальнейшем использовать

const { border, bg } = options.color; // Эта структура называется деструктуризацией
console.log(border);
// Внутрь фигурных скобок помещается те переменные которые нужно вытащить
// После присваивания мы пердаем структру из которой мы хотим вытащить эти объекты
// Т.е деструктурировать - разделить на более мелкие и удобные кусочки
// Используется для более удобной работы с большой вложенностью внутри объектов 

// ВАЖНО! Строка на базовом уровне , тоже является объектом и получает этот метод через цепочку прототипов 

//----Массивы и псевдомассивы---

// Это структуры которые содержат элементы по порядку

const arr = [1, 2, 3, 4, 5, 6];

// Перебор массива
for ( let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}

for (let value of arr) {
    console.log(value); // value - это каждый отдельный элемент
}
// Создаем переменную в которой будут хранится все элементы массива. Далее указываем в каком массиве мы будем работать
// Свойство length состоит из последнего элемента в массиве + 1
// ВАЖНО!!! Пример
/*
const arr = [1, 2, 3, 4, 5, 6];
arr[99] = 0; // добавляем 0 на 99 позицию в массив
console.log(arr.length); // 100 т.е 99 элементов в массиве + 1
console.log(arr); // [1, 2, 3, 4, 5, 6 <94 empty items>, 0]; - Мы получаем массив с пустыми ячейками
*/

//--------ForEach()-----------
// Метод forEach() выполняет указанную функцию один раз для каждого элемента в массиве
arr.forEach( function (item, i, arr) {
    console.log(`${i}: ${item} внутри массива ${arr}`); // 0: 1 внутри массива 1, 2, 3, 4, 5, 6;
})
// Принимает в себя callback функцию
// Может принимать в себя 3 аргумента
// 1. Это тот элемент который мы сейчас перебираем назовем item. Назвать можно как угодно
// 2. Это номер по порядку
// 3. Это ссылка ссылка на тот массив который мы перебираем arr
// callback функция нужно чтобы строго выполнится после определенных действий

//ВАЖНО!!! Когда использовать цикл , а когда for of?
// В for of мы можем использовать такие ключевые слова как break и continue. Очень важны если нам когда-то нужно будет остановить цикл либо полностью либо пропустить одно повторение
// Когда мы испльзуем forEach мы не сможем его остановить на каком-то этапе

// Методы перебора массивов
// .map - как и forEach перебирает элемент, но при этом его модифицировать. В конце вернет новый массив с модифицированными элементами
// .filter - отфильтровываем по тому критерию который мы туда задаем 
// Эти методы так же являются методами трансформации массивов, они берут исходный материал и его модифицируют. А метод forEach просто его перебирает

// split - превращает строку в массив. 
const str = prompt('', ''); // Получаем от сервера данные в виде строки с разделителем
const products = str.split(', '); // Внутри должны указать, через какой разделитель будут элементы в строке. За
// Команда prompt существует только внутри браузера
// Результат работы split() - 0: 'qqqq', 1: 'qqqq' и тд по кол-во элементов
// .join() - объединение элемента массива в строку. Должны указать через какой разделитель будут выводится элементы на страницу 
console.log(products.join('; ')); // Получаем строку через ; . wwww; ewweq; ewrwer
// .sort() - сортирует элементы внутри массива как строки
// Если массив из строк , отсотрирует по алфовиту
// Если масив из чисел, отсортирует как строки по первому символу числа  [10, 12, 2, 26, 28, 8]
// Метод .sort() - может принимать в себя callback функцию , как именно сортировать данный массив

const arr = [10, 12, 2, 26, 28, 8];
arr.sort(compereNum);

function compereNum(a, b) {
    return a - b
}
// Элементы отсортируются по порядку
// Метод имеет внутри себя алгоритм быстрой сортировки 

// Понятие псевдомассивов 

// Когда мы работаем с элементами на странице, то мы будем полуать псевдомассивы
// Это объект структура которого совподает с структурой массива. У таких массивов не будет никаких методов, это просто структура которая хранит данне по порядку

// Передача по ссылке или по значению

/*
Изменяя что-то внутри копий, мы модифицируем изначальный объект
Когда мы работаем с какими-то примитивными типами данных, то они передаются по значению
*/
let a = 5; // Такая констукция, работает только с примитивами
    b = a;

b = b + 5;
console.log(b);
console.log(a);

const obj = {
    a: 5,
    b: 1
}
const copy = obj; // В переменную copy кладется ссылка на уже существующий объект
copy.a = 10; // Когда мы модифицируем копию, мы как бы модифицируем наш изначальный объект
// Когда мы работаем с объектами (массивы, функции и т.д), то у нас идет передача не по значению, а по ссылке

// Создание копии объекты с помощью цикла
function copeOne (mainObj) {
    let copeObj = {};

    let key; // Переменную можно создавать и вне функции
    for ( key in mainObj ) {
        copeObj[key] = mainObj[key];
    }
    return copeObj; // Возвращаем результат, чтобы с ним можно было работать
}
// Берем copeObj, внутри создаем новое свойство через [] квадратные скобки. Это свойство которое будет содержать в себе такое же обозначение как и в  главном объекте
// Дальше мы делаем копию из нашего главного объекта 
// Мы пройдемся по нашему старому объекту , скопируем его свойства и запишем их в новую копию. Которая изначально была пустым объектом 

const number = {
    a: 2,
    b: 5,
    c: {
        x: 7,
        y: 4
    }
}

const newNumbers = copy(number) // Мы создали копию

newNumbers.a = 10;
newNumbers.c.x = 10;
// Когда мы вот так клонируем объекты есть 2 очень важных понятия это глубокие и поверхностные копии обхъектов 
// Сечас мы создали поверхностную копию, она берет все обычные свойства которые были в родителе и создает как-бы независимые структуры
// Как только у нас появляется вложеная структрура, то это свойство опять же будет иметь ссылочный тип данных 

// Создание копий с помощью object.assign()

// У нашего глабального типа данных object есть такой метод который позволяет вам соеденить сразу несколько объектов 
const add = {
    d: 17,
    e: 20
}
console.log(Object.assign(number, add))
// Первым аргументом мы передаем тот объект в который хотим все это поместить 
// Вторым аргкментом тот объект который помещаем 
// Мы создали независимую поверхностную копию объекта, она никак не зависит не от number и add

// Тоже самое мы можем сделать с пустым объектом чтобы просто создать копию объекта number мы заменяем на пустой объект
// console.log(Object.assign({}, add)) - у нас создается новый объект, в него помещаются какой-то старый объект и мы получаем отдельную копию
const clone = Object.assign({}, add)
clone.d = 20;

console.log(add) // { d: 17, e: 20 }
console.log(clone) // { d: 20, e: 20 } - клонированныей объект

// Методы для создания копии массива 
const oldArray = ['a', 'b', 'c'];
const newArray = oldArray; // В данном случае в newArray положиться ссылка на oldArray. Изменяя newArray будем изменять oldArray

const newArray = oldArray.slice(); // Метод который позволяет просто скопировать старый массив
// В него можно передать аргументы по количеству элементов.
newArray[1] = 'asdasdasd';
console.log(newArray); // Результтат ['a', 'asdasdasd', 'c']
console.log(oldArray); // Результтат ['a', 'b', 'c']

// Новые стандарты ES7 и ES8
// 4 способом создания поверхностных копий будет использование оператора разворота. ES6 появился для массивов, в ES7 для объектов 
// Оператор называется Spread - оператор разворота, имеет такое название т.к он разворачивает структуру и привращает ее в набор каких-то данных 
const video = ['youtube', 'vimeo', 'rutube'],
      blogs = ['wordpress', 'livejournal', 'blogger'],
      internet = [...video, ...blogs, 'vk', 'facebook'];
// Сделаем так чтобы в этой переменной склонировались все значения из переменной video, blogs, и еще добавились какие-то свои которые там будут
// Мы берем перменную video и spread оператор должен развернуть эту структуру на отдельны значения для этого мы ставим троеточие перед переменной ...video, так же делаем с blogs
// Оператора ... троеточие развернул массивы на отдельные элементы и совместил в новом массиве 

function log(a, b, c) { // Фунции log используются обычно для логирования каких-то данных
    console.log(a)
    console.log(b)
    console.log(c)
}
const num = [2, 5, 7]; // Предположим что массив сформировался на сервере, на стороннем ресурсе
// Например: 1. Ссылка на сам источник, ссылка на заглушку(картинку которая стоит перед этим), ссылка на автора
// Все эти 3 аргумента нам нужно передать в функцию log(). Функция принимает 3 аргумента,а не массив

log(...num); // Разделит массив на аргументы и передаст их внутрь функции

// 4 способ создания поверностных копий объекта. operator spread
const array = ['a', 'b'];

const newAarray = [...array]; // Теперь в переменной newAarray лежит новая копия массива array

// Копия объекта 

const q = {
    one: 1,
    two: 2
}

const newObj = {...q}; // Копия объекта записанная в переменную newObj
// Создаем пустой объект 


// Объектно орентированное программирование. ООП
// Прототипно ориентированное программирование 

// Разные языки используют разные принципы внутри себя. 
// Мы предстовляем любую вещь как объект с набором свойств и методов.

// Когда строка написано просто в ковычках, то это обычный примитив. Простой тип данных 
// Но как только мы пытаемся вызвать какой-то метод или свойства, то JavaScript оборачивает эту строку в объект и после модифицикации возвращает строку обратно
let str = 'some';
let strObj = new String(str);
// Внутрь мы помещаем str на основании строки some мы создаем еще новую строку 
console.log(typeof(str)); // Результат тип string 
console.log(typeof(strObj)); // Результат тип object 

const soldier = {
    health: 400,
    armor: 100
};
const jonh = {
    health: 100,
};
// Нам нужно установить связь чтобы John умел делать тоже самое что и soldier, имел все теже свойства, а некоторые были модифицированны

// Устаревший формат который может встретится. Но уже не используется 
jonh.__proto__ = soldier; // Мы установили прототипом jonh будет soldier - не используется 
console.log(jonh.armor) // Результат 100

// Несмотря на то что у объект jonh только одно свойство, благодаря прототипам он так же получил свойство armor которое было у его прототипа 

Object.setPrototypeOf(jonh, soldier); // Команда получает прототип

// Вскобках пишется тот объект которому будет назначен прототип, а вторым напишем тот объект прототип которого мы устанавливаем

// Обычно когда мы работаем с кодом мы не создаем какие-то ненужные объекты, а потом назначаем прототипы.
// А делаем это на этапе создания объекта

const jonh = Object.create(soldier) // Используется для создания прототипных связей

// Мы создаем новый объект, и на базовом уровне прописать прототип 
// Мы создаем объект jonh который будет прототипно наследоваться от Soldier. Чтобы все также Jonh имел доступ к функциям, методам, свойствам
// Объект jonh еще ничего не содержит, но уже умеет делать все что делает soldier

// ООП - это наука как правильно делать архитектуру. Так же JS можно назвать прототипным языком т.к это частный случай OOП

// Отлавливаем ошибки в коде с помощью консоли разработчика. Breackpoints
/*
- Вкладка Sourse - это вкладка со всеми исходными материалами которые нам доступны в проекте который открыт на странице
- Вкладка Network - отвечает за работу с сетью. Сдель мы можем отслеживать как загружаются скрипты, картинки, HTML структуры
- Но самое главное сдесь мы можем отслеживать запросы которые будут уходит на сайте. Чтобы получить какие-то данные, или отправить данные
- Вкладка performance - мы можем сдесь записать как работает, загружается какая-то структура
- Вкладка Application - можем посмотреть на различные application которые установленны. Например Storage

- Как дебажить наш код?
- Как получать промежуточные результаты которые возникают на том или ином шаге выполнения нашей программы. Для этого у нас существует такая вкладка Source

debugger - в коде является брейкпоинтом. Он останавливает выполнение кода в консоли на себе

Динамическая типизация:
- Это возможность одного типа данных превращатся в другой. Т.е число может стать строкой, строка числом, а объект boolean значением
В мире программирования, в других языках есть и статическая типизация. Когда число всегда остается числом


Варианты 'Что-то превратить в строку' toString

- Старый и очень редко исользуемый способ это команда String
console.log(typeof(String(null))) // string

Команда String взяла и превратила null в строковый тип данных. Просто обернула в ковычки

- Конкатенация

console.log(typeof(5 + '')) // string

const num = 5
console.log('https://vk.com/catalog' + num) - страрый формат который можно встретить

const fontSize = 26 + 'px'

Когда мы что-то складываем со строкой. Это сложение строки с чем-то
При сложении со строкой у нас все равно получается строка


Варианты 'Что угодно превратить в число' Number


- Старый и очень редко исользуемый способ это команда Number
console.log(typeof(number('4'))) // number

- Более простой и удобный способ: Унарный плюс
console.log(typeof(+'5'))

Знак плюс который ставят перед каким-то типом данных

- Метод parseInt
console.log(typeof(parseInt('15px', 10)))


Варианты типизации в Boolean значение

0, '', null, undefined, NaN   // false

Все остальное что есть в JS все будет true

let switcher = null

if (switcher) {
    console.log('Working...')
}

switcher = 1

if (switcher) {
    console.log('Working...')
}

Такой прием мы будем встречать в программах. Что изначально какая-то переменная/переключатель у нас ничего не содержит 
Что в будующем этот перключатель поменяет значение 
Условие не выполнится. Почему?

Потому что мы сейчас обращаемся к переменной switcher. Мы логически ее проверяем, видим что внутри у нас null. null всегда false
Теперь во втором условии все сработает. Т.к в логическом контексте 1 будет правдой

Точно такойже прием используется с элементами на странице. Если у нас какого-то элемента просто не существует вместо него будет null
На одном из этапов у нас на странице появляется этот элемент. Условие узнает что элемент на странице появился
И начинает выполнять какие-то действия

- Вместо Number подстовляем Boolean 
console.log(typeof(Boolean('4')))

- Два знака отрицания дают boolean значение 
console.log(typeof(!!''44444)) 








*/